

================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\analyze-zip\route.ts
================================================================================

import { NextResponse } from "next/server";
import JSZip from "jszip";
import crypto from "crypto";
import path from "path";
import fs from "fs/promises";
import sharp from "sharp";
import { getFilePath } from "@/lib/fileStorage"; 

type AnalyzedItem = {
  id: string;
  name: string;
  type: "image" | "html" | "other";
  size: number;
  url: string;
  previewUrl?: string;
  html?: boolean;
};

type UploadAnalysis = {
  uploadId: string;
  isSingleCreative: boolean;
  items: AnalyzedItem[];
  counts: { images: number; htmls: number; others: number; total: number };
};

export const dynamic = "force-dynamic";

export async function POST(req: Request) {
  try {
    const formData = await req.formData();
    const file = formData.get("file");

    if (!file || !(file instanceof Blob)) {
      return NextResponse.json({ error: "ZIP file is required" }, { status: 400 });
    }

    const arrayBuffer = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(Buffer.from(arrayBuffer));

    const uploadId = crypto.randomUUID();

    const items: AnalyzedItem[] = [];
    let images = 0, htmls = 0, others = 0;

    const normalize = (p: string) =>
      p.replace(/\\/g, "/").replace(/\.\.(\/|\\)/g, "").replace(/^\/+/, "");

    const thumbsPrefix = "thumbs";

    const writeFile = async (relPath: string, data: Buffer) => {
      const abs = await getFilePath(uploadId, relPath);
      await fs.mkdir(path.dirname(abs), { recursive: true });
      await fs.writeFile(abs, data);
      return abs;
    };

    const entries = Object.values(zip.files).filter((f) => !f.dir);

    for (const entry of entries) {
      const rel = normalize(entry.name);
      if (!rel) continue;

      const ext = rel.split(".").pop()?.toLowerCase() || "";
      const isImage = ["png", "jpg", "jpeg", "gif", "webp"].includes(ext);
      const isHtml = ["html", "htm"].includes(ext);

      const data = Buffer.from(await entry.async("nodebuffer"));
      await writeFile(rel, data);

      const baseUrl = `/api/files/${encodeURIComponent(uploadId)}/`;
      const fileUrl = baseUrl + rel;

      const item: AnalyzedItem = {
        id: uploadId,
        name: rel,
        type: isImage ? "image" : isHtml ? "html" : "other",
        size: data.length,
        url: fileUrl,
        html: isHtml || undefined,
      };

      if (isImage) {
        const thumbRel = `${thumbsPrefix}/${rel.replace(/\//g, "__")}.jpg`;
        try {
          const thumb = await sharp(data)
            .resize(480, 480, { fit: "inside", withoutEnlargement: true })
            .jpeg({ quality: 80 })
            .toBuffer();
          await writeFile(thumbRel, thumb);
          item.previewUrl = baseUrl + thumbRel;
        } catch {
          item.previewUrl = fileUrl;
        }
      }

      items.push(item);
      if (isImage) images++;
      else if (isHtml) htmls++;
      else others++;
    }

    const isSingleCreative =
      items.filter((i) => i.type === "html" || i.type === "image").length === 1;

    const analysis: UploadAnalysis = {
      uploadId,
      isSingleCreative,
      items,
      counts: { images, htmls, others, total: items.length },
    };

    return NextResponse.json(analysis, { status: 200 });
  } catch (e) {
    return NextResponse.json(
      { error: "ZIP analysis failed", detail: e instanceof Error ? e.message : String(e) },
      { status: 500 }
    );
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\check-telegram-start\route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server'
import { getPool } from '@/lib/db'

export async function POST(req: NextRequest) {
  try {
    const { username } = await req.json();
    if (!username) {
      return NextResponse.json({ started: false, message: 'username required' }, { status: 400 });
    }

    const clean = String(username).replace(/^@/, '').trim();

    const pool = getPool();
    const { rows } = await pool.query(
      `SELECT username, chat_id, first_name
       FROM telegram_users
       WHERE LOWER(username) = LOWER($1)
       LIMIT 1`,
      [clean]
    );

    if (rows.length) {
      return NextResponse.json({ started: true, user: rows[0] });
    }

    return NextResponse.json({ started: false, message: 'not_found' });
  } catch (e: unknown) {
    return NextResponse.json({ started: false, message: e instanceof Error ? e.message : 'error' }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\creative\delete\route.ts
================================================================================

import { NextRequest, NextResponse } from "next/server";

export const runtime = "nodejs";

export async function POST(req: NextRequest) {
  try {
    const { fileUrl, creativeId, previewUrl, relatedIds = [] } = await req.json() as {
      fileUrl?: string; 
      creativeId?: string; 
      previewUrl?: string; 
      relatedIds?: string[]
    };

    const ids = new Set<string>();
    if (creativeId) ids.add(creativeId);
    if (fileUrl) {
      const m = fileUrl.match(/\/api\/files\/([^/]+)\//) || fileUrl.match(/[?&]id=([^&]+)/);
      if (m) ids.add(decodeURIComponent(m[1]));
    }
    if (previewUrl) {
      const m = previewUrl.match(/\/api\/files\/([^/]+)\//) || previewUrl.match(/[?&]id=([^&]+)/);
      if (m) ids.add(decodeURIComponent(m[1]));
    }
    for (const x of relatedIds) if (x) ids.add(x);

    const res = await fetch(`${process.env.NEXT_PUBLIC_BASE_PATH || ''}/api/files/bulk-delete`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ids: Array.from(ids) }),
    });

    const out = await res.json();
    return NextResponse.json(out, { status: res.status });
  } catch (e) {
    console.error("delete creative error:", e);
    return NextResponse.json({ error: "Failed to delete creative" }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\creative\rename\route.ts
================================================================================

import { NextRequest, NextResponse } from "next/server";
import { getFilePath } from "@/lib/fileStorage";
import { rename as fsRename } from "fs/promises";

export const runtime = "nodejs";

export async function POST(req: NextRequest) {
  try {
    const { fileUrl, newName } = (await req.json()) as { fileUrl?: string; newName: string };
    if (!fileUrl || !newName) {
      return NextResponse.json({ error: "fileUrl and newName required" }, { status: 400 });
    }

    const m = fileUrl.match(/\/api\/files\/([^/]+)\/([^?#]+)/);
    if (!m) return NextResponse.json({ error: "bad fileUrl" }, { status: 400 });
    const id = decodeURIComponent(m[1]);
    const oldName = decodeURIComponent(m[2]);

    const oldAbs = await getFilePath(id, oldName);
    const newAbs = await getFilePath(id, newName);
    await fsRename(oldAbs, newAbs);

    return NextResponse.json({
      ok: true,
      newName,
      fileUrl: `/api/files/${encodeURIComponent(id)}/${encodeURIComponent(newName)}`,
    });
  } catch (e) {
    console.error("rename error:", e);
    return NextResponse.json({ error: "Failed to rename" }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\creative\save\route.ts
================================================================================

import { NextRequest, NextResponse } from "next/server";
import { getPool } from "@/lib/db";
import { createSubmissionEmail, sendEmail } from "@/lib/emailService";

function parseFileUrl(u: string) {
  try {
    const m = u.match(/\/api\/files\/([^/]+)\/([^?#]+)/);
    if (m) {
      return {
        id: decodeURIComponent(m[1]),
        name: decodeURIComponent(m[2]),
        file_url: u,
        file_key: `${decodeURIComponent(m[1])}/${decodeURIComponent(m[2])}`,
        original_filename: decodeURIComponent(m[2]),
      };
    }
  } catch {}
  return { file_url: u };
}

export const runtime = "nodejs";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    const {
      offerId,
      fromLines,
      subjectLines,
      notes,
      priority = "Moderate",
      email: contactEmail,
      firstName,
      lastName,
      files = [],
    } = body || {};

    if (!offerId || !contactEmail || !Array.isArray(files) || files.length === 0) {
      return NextResponse.json(
        { error: "offerId, email and at least one file are required" },
        { status: 400 }
      );
    }

    const pool = getPool();
    const client = await pool.connect();
    let submissionId: number | null = null;

    try {
      await client.query("BEGIN");

      const sub = await client.query(
        `INSERT INTO submissions (
          offer_id, priority, contact_method, contact_info, 
          from_lines, subject_lines, other_request
        ) VALUES ($1,$2,$3,$4,$5,$6,$7) RETURNING id`,
        [
          String(offerId),
          String(priority),
          "email",
          String(contactEmail),
          String(fromLines || ""),
          String(subjectLines || ""),
          String(notes || ""),
        ]
      );

      submissionId = sub.rows[0].id;

      for (const f of files as Array<{ fileUrl: string; fileName?: string }>) {
        const meta = parseFileUrl(f.fileUrl);
        await client.query(
          `INSERT INTO submission_files (
            submission_id, file_url, file_key, original_filename, 
            creative_from_lines, creative_subject_lines, creative_notes, creative_html_code
          ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8)`,
          [
            submissionId,
            meta.file_url ?? null,
            meta.file_key ?? null,
            meta.original_filename ?? f.fileName ?? null,
            fromLines ?? null,
            subjectLines ?? null,
            notes ?? null,
            null,
          ]
        );
      }

      await client.query("COMMIT");
    } catch (e) {
      await client.query("ROLLBACK");
      throw e;
    } finally {
      client.release();
    }

    const contactName = [firstName, lastName].filter(Boolean).join(" ") || "there";
    const trackingLink = `https://www.bigdropsmarketing.com/tracking_link/BDMG${submissionId}`;
    const html = createSubmissionEmail({
      contactName,
      priority: String(priority),
      trackingLink,
    });
    await sendEmail({
      to: contactEmail,
      subject: "Your Submission Has Been Received!",
      html,
    });

    return NextResponse.json({ ok: true, submissionId, trackingLink });
  } catch (e) {
    console.error("save creative error:", e);
    return NextResponse.json({ error: "Failed to save creative" }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\creative\save-html\route.ts
================================================================================

import { NextRequest, NextResponse } from "next/server";
import { getFilePath } from "@/lib/fileStorage";
import { rename as fsRename, writeFile } from "fs/promises";

export const runtime = "nodejs";

export async function POST(req: NextRequest) {
  try {
    const { fileUrl, html, newFileName } = (await req.json()) as {
      fileUrl: string; html: string; newFileName?: string;
    };
    if (!fileUrl || typeof html !== "string") {
      return NextResponse.json({ error: "fileUrl and html required" }, { status: 400 });
    }

    const m = fileUrl.match(/\/api\/files\/([^/]+)\/([^?#]+)/);
    if (!m) return NextResponse.json({ error: "bad fileUrl" }, { status: 400 });
    const id = decodeURIComponent(m[1]);
    const name = decodeURIComponent(m[2]);

    const abs = await getFilePath(id, name);
    await writeFile(abs, html, "utf8");

    let finalName = name;
    if (newFileName && newFileName !== name) {
      const newAbs = await getFilePath(id, newFileName);
      await fsRename(abs, newAbs);
      finalName = newFileName;
    }

    return NextResponse.json({
      ok: true,
      fileUrl: `/api/files/${encodeURIComponent(id)}/${encodeURIComponent(finalName)}`
    });
  } catch (e) {
    console.error("save-html error:", e);
    return NextResponse.json({ error: "Failed to save HTML" }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\everflow\offers\route.ts
================================================================================


import { NextResponse } from 'next/server';

export async function GET() {
  const EVERFLOW_API_KEY = process.env.EVERFLOW_API_KEY;
  if (!EVERFLOW_API_KEY) {
    return NextResponse.json({ error: 'Everflow API key is not configured.' }, { status: 500 });
  }

  try {
    try {
      const runnableResponse = await fetch('https://api.eflow.team/v1/affiliates/offersrunnable', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'X-Eflow-API-Key': EVERFLOW_API_KEY,
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
        },
        cache: 'no-store',
      });

      if (runnableResponse.ok) {
        const runnableData = await runnableResponse.json();
        if (runnableData.offers?.length) {
          const offerIds = runnableData.offers
            .map((o: { network_offer_id: string | number }) => o.network_offer_id.toString())
            .sort((a: string, b: string) => parseInt(a, 10) - parseInt(b, 10));
          return NextResponse.json(offerIds);
        }
      }
    } catch {}

    try {
      const allOffersResponse = await fetch('https://api.eflow.team/v1/affiliates/alloffers', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'X-Eflow-API-Key': EVERFLOW_API_KEY,
          'User-Agent':
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
        },
        cache: 'no-store',
      });

      if (allOffersResponse.ok) {
        const allOffersData = await allOffersResponse.json();
        if (allOffersData.offers?.length) {
          const offerIds = allOffersData.offers
            .map((o: { network_offer_id: string | number }) => o.network_offer_id.toString())
            .sort((a: string, b: string) => parseInt(a, 10) - parseInt(b, 10));
          return NextResponse.json(offerIds);
        }
      }
    } catch {}

    try {
      const networkResponse = await fetch(
        'https://api.eflow.team/v1/networks/offerstable?page=1&page_size=1000',
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Eflow-API-Key': EVERFLOW_API_KEY,
            'User-Agent':
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
          },
          body: JSON.stringify({
            filters: { offer_status: 'active' },
            sort_by: { column: 'created', order: 'desc' },
          }),
          cache: 'no-store',
        }
      );

      if (networkResponse.ok) {
        const networkData = await networkResponse.json();
        const offers = networkData.offers || networkData.entries || [];
        if (offers.length) {
          const allOfferIds = offers.map(
            (o: { network_offer_id: string | number }) => o.network_offer_id.toString()
          );
          const unique = Array.from(new Set(allOfferIds)).sort(
            (a, b) => parseInt(a as string, 10) - parseInt(b as string, 10)
          );
          return NextResponse.json(unique);
        }
      }
    } catch {}

    return NextResponse.json([]);
  } catch {
    return NextResponse.json({ error: 'An internal server error occurred.' }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\files\[...path]\route.ts
================================================================================

ERROR: Could not read file


================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\files\[id]\[...path]\route.ts
================================================================================

ERROR: Could not read file


================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\files\[id]\[name]\route.ts
================================================================================

ERROR: Could not read file


================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\files\[id]\route.ts
================================================================================

ERROR: Could not read file


================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\files\bulk-delete\route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { deleteFileTreeById, getFileDir } from '@/lib/fileStorage';
import { stat } from 'fs/promises';

export const dynamic = 'force-dynamic';

type Req = { ids: string[] };

export async function POST(req: NextRequest) {
  try {
    const { ids } = (await req.json()) as Req;
    if (!Array.isArray(ids) || !ids.length) {
      return NextResponse.json({ error: 'ids[] required' }, { status: 400 });
    }

    const results = [];
    let reclaimed = 0;

    for (const id of ids) {
      try {
        await stat(getFileDir(id)); // exists?
        const r = await deleteFileTreeById(id);
        reclaimed += r.bytesReclaimed;
        results.push({ id, ok: true, deleted: r.filesDeleted.length, bytes: r.bytesReclaimed });
      } catch {
        results.push({ id, ok: false, reason: 'not-found' });
      }
    }

    return NextResponse.json({ success: true, results, totalReclaimed: reclaimed });
  } catch (e) {
    console.error('Bulk delete error:', e);
    return NextResponse.json({ error: 'Failed bulk-delete' }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\generate-email-content\route.ts
================================================================================

import { NextResponse } from "next/server";

type Req = {
  creativeType?: string;
  audience?: string;
  brandVoice?: string;
  industry?: string;
  campaignGoal?: string;
  notes?: string;
  sampleText?: string;
  maxFrom?: number;
  maxSubject?: number;
};

type Resp = {
  fromLines: string[];
  subjectLines: string[];
};

export const dynamic = "force-dynamic";

const SYS_INSTRUCTIONS = `
You generate high-performing "From" lines and Subject lines for email campaigns.
Return STRICT JSON ONLY with keys: fromLines (string[]), subjectLines (string[]).
Do not include commentary.
Rules:
- Make From lines look like real people/brands (avoid spammy ALL CAPS).
- Subject lines: concise, curiosity-driven, 35â€“55 chars when possible, no clickbait.
- Avoid spam trigger words (free!!!, winner, guarantee).
- Tailor tone to brandVoice and audience. 
`;

function buildUserPrompt(payload: Req) {
  const {
    creativeType = "Email",
    audience = "",
    brandVoice = "",
    industry = "",
    campaignGoal = "",
    notes = "",
    sampleText = "",
    maxFrom = 5,
    maxSubject = 10,
  } = payload;

  return `
Context:
- Creative Type: ${creativeType}
- Audience: ${audience || "n/a"}
- Brand Voice: ${brandVoice || "n/a"}
- Industry: ${industry || "n/a"}
- Campaign Goal: ${campaignGoal || "n/a"}
- Extra Notes: ${notes || "n/a"}

Sample Creative/Text (optional):
${sampleText || "n/a"}

Requirements:
- Generate up to ${maxFrom} From lines and up to ${maxSubject} Subject lines.
- Output JSON: {"fromLines": [...], "subjectLines": [...]}
`;
}

async function callAnthropic(jsonPrompt: string) {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  const model = process.env.CLAUDE_MODEL || "claude-3-5-sonnet-20240620";
  if (!apiKey) return null;

  const res = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": apiKey,
      "anthropic-version": "2023-06-01",
    },
    body: JSON.stringify({
      model,
      max_tokens: 800,
      system: SYS_INSTRUCTIONS,
      messages: [{ role: "user", content: jsonPrompt }],
      temperature: 0.7,
    }),
  });

  if (!res.ok) {
    const t = await res.text().catch(() => "");
    throw new Error(`Claude error: ${res.status} ${t}`);
  }
  const data = await res.json();

  const text =
    data?.content?.map((b: { text?: string }) => b?.text).filter(Boolean).join("\n") ?? "";
  return text;
}

async function callOpenAI(jsonPrompt: string) {
  const apiKey = process.env.OPENAI_API_KEY;
  const model = process.env.OPENAI_LLM_MODEL || "gpt-4o-mini";
  if (!apiKey) return null;

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model,
      temperature: 0.7,
      messages: [
        { role: "system", content: SYS_INSTRUCTIONS },
        { role: "user", content: jsonPrompt },
      ],
      response_format: { type: "json_object" },
    }),
  });

  if (!res.ok) {
    const t = await res.text().catch(() => "");
    throw new Error(`OpenAI error: ${res.status} ${t}`);
  }
  const data = await res.json();
  const text = data?.choices?.[0]?.message?.content ?? "";
  return text;
}

function safeParseLLMJson(text: string | null): Resp | null {
  if (!text) return null;
  try {
    const parsed = JSON.parse(text);
    const fromLines = Array.isArray(parsed.fromLines) ? parsed.fromLines : [];
    const subjectLines = Array.isArray(parsed.subjectLines) ? parsed.subjectLines : [];
    return { fromLines, subjectLines };
  } catch {
    const match = text.match(/\{[\s\S]*\}$/);
    if (match) {
      try {
        const parsed = JSON.parse(match[0]);
        const fromLines = Array.isArray(parsed.fromLines) ? parsed.fromLines : [];
        const subjectLines = Array.isArray(parsed.subjectLines) ? parsed.subjectLines : [];
        return { fromLines, subjectLines };
      } catch {}
    }
    return null;
  }
}

export async function POST(req: Request) {
  try {
    const payload = (await req.json()) as Req;
    const userPrompt = buildUserPrompt(payload);

    let text: string | null = null;
    try {
      text = await callAnthropic(userPrompt);
    } catch (e) {
      console.error(e);
    }
    if (!text) {
      text = await callOpenAI(userPrompt);
    }
    const parsed = safeParseLLMJson(text);

    if (!parsed || (!parsed.fromLines.length && !parsed.subjectLines.length)) {
      return NextResponse.json(
        { error: "Model returned empty or invalid JSON" },
        { status: 502 }
      );
    }

    const uniq = (arr: string[]) =>
      Array.from(new Set(arr.map((s) => s.trim()))).filter(Boolean);

    const resp: Resp = {
      fromLines: uniq(parsed.fromLines).slice(0, payload.maxFrom ?? 5),
      subjectLines: uniq(parsed.subjectLines).slice(0, payload.maxSubject ?? 10),
    };
    return NextResponse.json(resp, { status: 200 });
  } catch (e) {
    return NextResponse.json(
      { error: "Generation failed", detail: e instanceof Error ? e.message : String(e) },
      { status: 500 }
    );
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\get-file-content\route.ts
================================================================================

import { NextResponse } from "next/server";
import { getFilePath } from "@/lib/fileStorage";
import { rewriteHtmlAssets } from "@/lib/assetRewriter";

export const dynamic = "force-dynamic";

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const fileId = searchParams.get("fileId") || "";
    const fileUrl = searchParams.get("fileUrl") || "";
    const processAssets = (searchParams.get("processAssets") || "false") === "true";

    if (!fileId) {
      return NextResponse.json({ error: "fileId required" }, { status: 400 });
    }

    const decoded = decodeURIComponent(fileUrl);
    const inferredName = decoded.split("/").filter(Boolean).slice(-1)[0] || "index.html";

    const absPath = await getFilePath(fileId, inferredName);
    const html = await (await import("fs/promises")).readFile(absPath, "utf8");

    if (!processAssets) {
      return new NextResponse(html, {
        status: 200,
        headers: { "Content-Type": "text/html; charset=utf-8" },
      });
    }

    const origin = process.env.NEXT_PUBLIC_BASE_PATH
      ? new URL(process.env.NEXT_PUBLIC_BASE_PATH, req.url).toString().replace(/\/$/, "")
      : new URL(req.url).origin;

    const base = `${origin}/api/files/${encodeURIComponent(fileId)}/`;
    const rewritten = rewriteHtmlAssets(html, base);

    return new NextResponse(rewritten, {
      status: 200,
      headers: { "Content-Type": "text/html; charset=utf-8" },
    });
  } catch (e) {
    return NextResponse.json(
      { error: "failed to load content", detail: e instanceof Error ? e.message : String(e) },
      { status: 500 }
    );
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\proofread\route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';

type Edit = { start: number; end: number; original: string; suggestion: string; reason: string; severity: 'minor'|'major' };

const RULES: Array<[RegExp, (m: RegExpExecArray) => string, string]> = [
  [/\bteh\b/gi, ()=>'the', 'common typo'],
  [/\bdont\b/gi, ()=>"don't", 'apostrophe'],
  [/\boccured\b/gi, ()=>'occurred', 'spelling'],
  [/\bseperate\b/gi, ()=>'separate', 'spelling'],
];

export async function POST(req: NextRequest) {
  const { text } = await req.json();
  if (typeof text !== 'string') return NextResponse.json({ error: 'text required' }, { status: 400 });

  const edits: Edit[] = [];
  for (const [re, fix, reason] of RULES) {
    let m: RegExpExecArray | null;
    while ((m = re.exec(text))) {
      const original = m[0];
      const suggestion = fix(m);
      const start = m.index;
      const end = m.index + m[0].length;
      edits.push({ start, end, original, suggestion, reason, severity: 'minor' });
    }
  }
  return NextResponse.json({ corrected: text, edits });
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\proofread-creative\route.ts
================================================================================

import { NextResponse } from "next/server";

type Req = {
  creativeId?: string;
  creativeType?: "email"|"display"|"search"|"social"|"native"|"push";
  fileType: "image"|"html";
  fileUrl?: string;
  htmlContent?: string;
  offerId?: string;
  industry?: string;
  targetAudience?: string;
  campaignGoal?: string;
  brandVoice?: string;
};

type Issue = { icon: string; type: string; original?: string; correction?: string; note?: string };
type Suggestion = { icon: string; type: string; description: string };
type QualityScore = { grammar: number; readability: number; conversion: number; brandAlignment: number };

type Resp = { success: boolean; issues: Issue[]; suggestions: Suggestion[]; qualityScore: QualityScore };

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

const SYSTEM = `
You are a precise creative proofreader and optimizer.
Return ONLY JSON with keys: issues (array), suggestions (array), qualityScore (object).
Be concise, practical, and avoid generic advice.
`;

function isAbsolute(u: string) {
  try { new URL(u); return true; } catch { return false; }
}

async function toDataUrl(abs: string) {
  const r = await fetch(abs, { cache: "no-store" });
  if (!r.ok) throw new Error(`fetch image failed (${r.status})`);
  const mime = r.headers.get("content-type") || "image/jpeg";
  const b64 = Buffer.from(await r.arrayBuffer()).toString("base64");
  return `data:${mime};base64,${b64}`;
}

async function normalizeImageForOpenAI(fileUrl: string, req: Request) {
  const origin = process.env.NEXT_PUBLIC_BASE_PATH
    ? new URL(process.env.NEXT_PUBLIC_BASE_PATH, req.url).origin
    : new URL(req.url).origin;

  const abs = isAbsolute(fileUrl) ? fileUrl : new URL(fileUrl, origin).toString();
  const host = new URL(abs).hostname;

  if (host === "localhost" || host === "127.0.0.1") {
    return await toDataUrl(abs);
  }
  return abs;
}

function baseContext(p: Req) {
  return `
Context:
- Creative Type: ${p.creativeType || "email"}
- Offer ID: ${p.offerId || "n/a"}
- Industry: ${p.industry || "n/a"}
- Audience: ${p.targetAudience || "n/a"}
- Campaign Goal: ${p.campaignGoal || "n/a"}
- Brand Voice: ${p.brandVoice || "n/a"}

Output JSON shape:
{
  "issues": [{"icon": "âš ï¸","type":"Grammar Error","original":"...","correction":"..."}],
  "suggestions": [{"icon":"ðŸ’¡","type":"Conversion Tip","description":"..."}],
  "qualityScore": {"grammar": 0-100,"readability":0-100,"conversion":0-100,"brandAlignment":0-100}
}
`;
}

async function callAnthropicJSON(prompt: string) {
  const key = process.env.ANTHROPIC_API_KEY;
  if (!key) return null;
  const model = process.env.CLAUDE_MODEL || "claude-3-5-sonnet-20240620";
  const res = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": key,
      "anthropic-version": "2023-06-01",
    },
    body: JSON.stringify({
      model,
      max_tokens: 1200,
      temperature: 0.3,
      system: SYSTEM,
      messages: [{ role: "user", content: prompt }],
    }),
  });
  if (!res.ok) return null;
  const data = await res.json();
  const text = (data?.content || []).map((b: { text?: string }) => b?.text).filter(Boolean).join("\n");
  return text || null;
}

async function callOpenAIJSON(prompt: string) {
  const key = process.env.OPENAI_API_KEY;
  if (!key) return null;
  const model = process.env.OPENAI_LLM_MODEL || "gpt-4o-mini";
  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${key}` },
    body: JSON.stringify({
      model, temperature: 0.3,
      messages: [{ role: "system", content: SYSTEM }, { role: "user", content: prompt }],
      response_format: { type: "json_object" },
    }),
  });
  if (!res.ok) return null;
  const data = await res.json();
  return data?.choices?.[0]?.message?.content ?? null;
}

async function callOpenAIVisionJSON(imageUrl: string, context: string) {
  const key = process.env.OPENAI_API_KEY;
  if (!key) return null;
  const model = process.env.OPENAI_VISION_MODEL || "gpt-4o-mini";
  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${key}` },
    body: JSON.stringify({
      model,
      temperature: 0.3,
      messages: [
        { role: "system", content: SYSTEM },
        {
          role: "user",
          content: [
            { type: "text", text: context + "\nAnalyze the image text, layout, and clarity. Return JSON only." },
            { type: "image_url", image_url: { url: imageUrl } },
          ],
        },
      ],
      response_format: { type: "json_object" },
    }),
  });
  if (!res.ok) return null;
  const data = await res.json();
  return data?.choices?.[0]?.message?.content ?? null;
}

function coerceResp(text: string | null): Resp | null {
  if (!text) return null;
  try {
    const p = JSON.parse(text);
    const issues = Array.isArray(p.issues) ? p.issues : [];
    const suggestions = Array.isArray(p.suggestions) ? p.suggestions : [];
    const q = p.qualityScore || {};
    const qualityScore: QualityScore = {
      grammar: Math.max(0, Math.min(100, Number(q.grammar || 0))),
      readability: Math.max(0, Math.min(100, Number(q.readability || 0))),
      conversion: Math.max(0, Math.min(100, Number(q.conversion || 0))),
      brandAlignment: Math.max(0, Math.min(100, Number(q.brandAlignment || 0))),
    };
    return { success: true, issues, suggestions, qualityScore };
  } catch { return null; }
}

export async function POST(req: Request) {
  try {
    const hasOpenAI = !!process.env.OPENAI_API_KEY;
    const hasClaude = !!process.env.ANTHROPIC_API_KEY;
    
    console.log("Proofread environment check:", {
      hasOpenAI,
      hasClaude,
      openaiModel: process.env.OPENAI_VISION_MODEL || "gpt-4o-mini",
      claudeModel: process.env.CLAUDE_MODEL || "claude-3-5-sonnet-20240620"
    });

    const payload = (await req.json()) as Req;
    const ctx = baseContext(payload);

    let out: Resp | null = null;

    if (payload.fileType === "html") {
      const textOnly = (payload.htmlContent || "")
        .replace(/<script[\s\S]*?<\/script>/gi, "")
        .replace(/<style[\s\S]*?<\/style>/gi, "")
        .replace(/<[^>]+>/g, " ")
        .replace(/\s+/g, " ")
        .trim()
        .slice(0, 15000); // safety

      const prompt = `${ctx}\n\nHTML TEXT (truncated):\n${textOnly}\n\nReturn JSON.`;
      out = coerceResp(await callAnthropicJSON(prompt)) || coerceResp(await callOpenAIJSON(prompt));
    } else if (payload.fileType === "image") {
      if (!payload.fileUrl) {
        return NextResponse.json({ success: false, error: "fileUrl required for image" }, { status: 400 });
      }
      const imageSource = await normalizeImageForOpenAI(payload.fileUrl, req);
      const context = `${ctx}\n\nIMAGE SOURCE: ${imageSource.startsWith("data:") ? "(inlined)" : imageSource}`;
      out = coerceResp(await callOpenAIVisionJSON(imageSource, context));
    }

    if (!out) { 
      return NextResponse.json({
        success: true,
        issues: [],
        suggestions: [{ icon: "â„¹ï¸", type: "Notice", description: "LLM unavailable; no issues detected." }],
        qualityScore: { grammar: 75, readability: 75, conversion: 70, brandAlignment: 80 },
      });
    }
    return NextResponse.json(out);
  } catch (e) {
    return NextResponse.json(
      { success: false, error: e instanceof Error ? e.message : String(e) },
      { status: 500 }
    );
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\proofread-image\route.ts
================================================================================

import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";
import { ProofreadResult } from "@/types/proofread";

export const runtime = "nodejs";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY || "" });
const MODEL = process.env.OPENAI_VISION_MODEL || "gpt-4o-mini";

function asImagePart(imageUrlOrData: string) {
  return { type: "image_url" as const, image_url: { url: imageUrlOrData } };
}

function safeParseJson<T>(s: string, fallback: T): T {
  try {
    const cleaned = s.trim().replace(/^```(?:json)?/i, "").replace(/```$/,"").trim();
    return JSON.parse(cleaned) as T;
  } catch {
    return fallback;
  }
}

export async function POST(req: NextRequest) {
  try {
    if (!process.env.OPENAI_API_KEY) {
      return NextResponse.json({ error: "OPENAI_API_KEY not configured" }, { status: 500 });
    }

    const { imageUrl } = await req.json() as { imageUrl?: string };
    if (!imageUrl || typeof imageUrl !== "string") {
      return NextResponse.json({ error: "Missing imageUrl" }, { status: 400 });
    }

    const system =
      "You are a precise OCR + copy editor for ads. Extract all user-facing ad text from the image (ignore UI chrome, nav, boilerplate), then proofread it. " +
      'Return JSON ONLY: {"corrected": string, "edits": [{"start": number, "end": number, "original": string, "suggestion": string, "reason": string, "severity": "minor"|"major"}]}. ' +
      "Indices must reference the extracted text string.";

    const userText =
      "Extract headline, subheads, body, CTA. Preserve helpful line breaks. " +
      "Then proofread for clarity, spelling, grammar. Keep brand claims. Be concise. 'major' only for meaning/policy-risk changes. Return JSON ONLY.";

    const resp = await openai.chat.completions.create({
      model: MODEL,
      temperature: 0,
      max_tokens: 900,
      messages: [
        { role: "system", content: system },
        { role: "user", content: [
            { type: "text", text: userText },
            asImagePart(imageUrl),
        ] }
      ],
    });

    const raw = resp.choices[0]?.message?.content ?? "";
    const result = safeParseJson<ProofreadResult>(raw, { corrected: "", edits: [] });

    const base = result.corrected || "";
    result.edits = (result.edits || []).filter(e =>
      Number.isFinite(e.start) && Number.isFinite(e.end) &&
      e.start >= 0 && e.end >= e.start && e.end <= base.length &&
      typeof e.original === "string" && typeof e.suggestion === "string"
    );

    return NextResponse.json(result);
  } catch (e) {
    console.error("proofread-image error", e);
    return NextResponse.json<ProofreadResult>({ corrected: "", edits: [] }, { status: 200 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\proofread-text\route.ts
================================================================================

import { NextRequest, NextResponse } from "next/server";
import Anthropic from "@anthropic-ai/sdk";
import { ProofreadResult } from "@/types/proofread";

export const runtime = "nodejs";

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY || "",
});

const MODEL = process.env.CLAUDE_MODEL || "claude-3-5-sonnet-20240620";

function safeParseJson<T>(s: string, fallback: T): T {
  try {
    const cleaned = s.trim().replace(/^```(?:json)?/i, "").replace(/```$/,"").trim();
    return JSON.parse(cleaned) as T;
  } catch {
    return fallback;
  }
}

export async function POST(req: NextRequest) {
  try {
    if (!process.env.ANTHROPIC_API_KEY) {
      return NextResponse.json({ error: "ANTHROPIC_API_KEY not configured" }, { status: 500 });
    }

    const { text } = await req.json() as { text?: string };
    if (!text || typeof text !== "string") {
      return NextResponse.json({ error: "Missing text" }, { status: 400 });
    }

    const systemPrompt =
      "You are a precise copy editor. Return JSON ONLY matching: " +
      `{"corrected": string, "edits": [{"start": number, "end": number, "original": string, "suggestion": string, "reason": string, "severity": "minor"|"major"}]}` +
      ". The indices MUST be 0-based offsets over the ORIGINAL input text. Keep meaning & claims; fix grammar/spelling/style. Use 'major' only if meaning/policy risk changes.";

    const userPrompt =
      `Input text:\n${text}\n\n` +
      "Find issues and propose minimal fixes. Keep indices aligned to the ORIGINAL input string.";

    const msg = await anthropic.messages.create({
      model: MODEL,
      max_tokens: 800,
      temperature: 0,
      system: systemPrompt,
      messages: [{ role: "user", content: userPrompt }],
    });

    const raw = (msg.content?.[0] as { text?: string })?.text ?? "";
    const result = safeParseJson<ProofreadResult>(raw, { corrected: text, edits: [] });

    result.edits = (result.edits || []).filter(e =>
      Number.isFinite(e.start) && Number.isFinite(e.end) &&
      e.start >= 0 && e.end >= e.start && e.end <= text.length &&
      typeof e.original === "string" && typeof e.suggestion === "string"
    );

    return NextResponse.json(result);
  } catch (e) {
    console.error("proofread-text error", e);
    return NextResponse.json<ProofreadResult>({ corrected: "", edits: [] }, { status: 200 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\submissions\route.ts
================================================================================

import { NextResponse } from 'next/server';
import { getPool } from '@/lib/db';
import { createSubmissionEmail, sendEmail } from '@/lib/emailService';

export const dynamic = 'force-dynamic';

export async function POST(request: Request) {
  try {
    const body = await request.json();

    const {
      offer_id,
      priority,
      contact_method,
      contact_info,
      from_lines,
      subject_lines,
      other_request,
      creatives = [],
      contact_name = 'there',
    } = body || {};

    if (!offer_id || !contact_info || !Array.isArray(creatives) || creatives.length === 0) {
      return NextResponse.json({ 
        error: 'Offer ID, contact info, and at least one creative are required.' 
      }, { status: 400 });
    }

    const pool = getPool();
    const client = await pool.connect();
    let submissionId: number | null = null;

    try {
      await client.query('BEGIN');

      const subRes = await client.query(
        `INSERT INTO submissions (
          offer_id, priority, contact_method, contact_info, 
          from_lines, subject_lines, other_request
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id`,
        [offer_id, priority, contact_method, contact_info, from_lines, subject_lines, other_request]
      );

      submissionId = subRes.rows[0].id;

      for (const creative of creatives) {
        await client.query(
          `INSERT INTO creative_files (
            submission_id, file_url, file_key, original_filename, 
            creative_from_lines, creative_subject_lines, creative_notes, creative_html_code
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
          [
            submissionId,
            creative.file_url ?? null,
            creative.file_key ?? null,
            creative.original_filename ?? null,
            creative.creative_from_lines ?? null,
            creative.creative_subject_lines ?? null,
            creative.creative_notes ?? null,
            creative.creative_html_code ?? null,
          ]
        );
      }

      await client.query('COMMIT');
    } catch (e) {
      await client.query('ROLLBACK');
      throw e;
    } finally {
      client.release();
    }

    const trackingLink = `https://www.bigdropsmarketing.com/tracking_link/BDMG${submissionId}`;

    if (contact_info) {
      const emailHtml = createSubmissionEmail({
        contactName: contact_name || 'there',
        priority: priority || 'Moderate',
        trackingLink,
      });
      await sendEmail({
        to: contact_info,
        subject: 'Your Submission Has Been Received!',
        html: emailHtml,
      });
    }

    return NextResponse.json({
      success: true,
      submissionId,
      trackingLink,
    });
  } catch (error) {
    console.error('Submission error:', error);
    return NextResponse.json({ error: 'Server error during submission.' }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\telegram\poll\route.ts
================================================================================

import { NextResponse } from 'next/server';
import { getPool } from '@/lib/db';

const TOKEN = process.env.TELEGRAM_BOT_TOKEN!;

async function getOffset() {
  const pool = getPool();
  const { rows } = await pool.query(
    `SELECT value FROM telegram_state WHERE key = 'last_update_id' LIMIT 1`
  );
  return rows[0]?.value ? parseInt(rows[0].value, 10) : undefined;
}

async function setOffset(id: number) {
  const pool = getPool();
  await pool.query(
    `INSERT INTO telegram_state(key, value, updated_at)
     VALUES('last_update_id', $1, NOW())
     ON CONFLICT (key) DO UPDATE SET value=$1, updated_at=NOW()`,
    [String(id)]
  );
}

async function sendTelegramMessage(chat_id: number, text: string) {
  await fetch(`https://api.telegram.org/bot${TOKEN}/sendMessage`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ chat_id, text, parse_mode: 'HTML', disable_web_page_preview: true }),
    cache: 'no-store',
  }).catch(() => {});
}

export async function POST() {
  try {
    if (!TOKEN) return NextResponse.json({ ok: false, error: 'TELEGRAM_BOT_TOKEN missing' }, { status: 500 });

    const offset = await getOffset();
    const url = new URL(`https://api.telegram.org/bot${TOKEN}/getUpdates`);
    if (offset) url.searchParams.set('offset', String(offset + 1));
    url.searchParams.set('timeout', '0');

    const res = await fetch(url.toString(), { cache: 'no-store' });
    const data = await res.json();

    if (!data.ok) {
      return NextResponse.json({ ok: false, error: 'getUpdates failed', data }, { status: 500 });
    }

    let highestId = offset ?? 0;
    for (const upd of data.result as Array<{ update_id: number; message?: { text?: string; chat?: { id: number; username?: string; first_name?: string } } }>) {
      if (upd.update_id > highestId) highestId = upd.update_id;

      const msg = upd.message;
      if (!msg) continue;

      const text = (msg.text || '').trim().toLowerCase();
      if (!text.startsWith('/start')) continue;

      const chatId = msg.chat?.id;
      const username: string | null = msg.chat?.username || null;
      const firstName: string | null = msg.chat?.first_name || null;
      
      if (!chatId) continue;

      const pool = getPool();
      const client = await pool.connect();
      try {
        await client.query('BEGIN');
        if (username) {
          await client.query(
            `INSERT INTO telegram_users (username, chat_id, first_name, created_at, updated_at)
             VALUES ($1,$2,$3,NOW(),NOW())
             ON CONFLICT (username)
             DO UPDATE SET chat_id=EXCLUDED.chat_id, first_name=EXCLUDED.first_name, updated_at=NOW()`,
            [username, chatId, firstName]
          );
        } else {
          await client.query(
            `INSERT INTO telegram_users (username, chat_id, first_name, created_at, updated_at)
             VALUES ($1,$2,$3,NOW(),NOW())
             ON CONFLICT (username) DO NOTHING`,
            [`chat_${chatId}`, chatId, firstName]
          );
        }
        await client.query('COMMIT');
      } catch (e) {
        await client.query('ROLLBACK');
        throw e;
      } finally {
        client.release();
      }

      await sendTelegramMessage(chatId,
        `âœ… Thanks${firstName ? `, <b>${firstName}</b>` : ''}! Your Telegram is now linked.\n\nReturn to the form and click <b>Verify</b>.`
      );
    }

    if (highestId) await setOffset(highestId);
    return NextResponse.json({ ok: true, processed: data.result?.length || 0, last_update_id: highestId });
  } catch (e: unknown) {
    return NextResponse.json({ ok: false, error: e instanceof Error ? e.message : 'poll error' }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\telegram\verify\route.ts
================================================================================


import { NextRequest, NextResponse } from "next/server";
import { getPool } from "@/lib/db";

export async function POST(req: NextRequest) {
  try {
    const { telegramId } = await req.json();

    if (!telegramId) {
      return NextResponse.json({ error: "Missing telegramId" }, { status: 400 });
    }

    const cleanUsername = telegramId.replace(/^@/, "").toLowerCase();

    const pool = getPool();
    const { rows } = await pool.query(
      `SELECT * FROM telegram_users WHERE LOWER(username) = $1 AND chat_id IS NOT NULL LIMIT 1`,
      [cleanUsername]
    );

    if (rows.length > 0) {
      return NextResponse.json({ verified: true, user: rows[0] });
    } else {
      return NextResponse.json({ verified: false });
    }
  } catch (e: unknown) {
    return NextResponse.json({ error: e instanceof Error ? e.message : 'verification error' }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\telegram-webhook\route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { getPool } from '@/lib/db';

const TOKEN = process.env.TELEGRAM_BOT_TOKEN!;
const SECRET = process.env.TELEGRAM_WEBHOOK_SECRET || '';

async function sendTelegramMessage(chat_id: number, text: string) {
  const url = `https://api.telegram.org/bot${TOKEN}/sendMessage`;
  await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ chat_id, text, parse_mode: 'HTML', disable_web_page_preview: true }),
    cache: 'no-store',
  }).catch(() => {});
}

export async function POST(req: NextRequest) {
  try {
    if (!TOKEN) {
      return NextResponse.json({ ok: false, error: 'BOT token not set' }, { status: 500 });
    }

    if (SECRET) {
      const got = req.headers.get('x-telegram-bot-api-secret-token');
      if (got !== SECRET) {
        return NextResponse.json({ ok: false, error: 'bad secret' }, { status: 401 });
      }
    }

    const update = await req.json();

    const msg = update?.message;
    if (!msg) return NextResponse.json({ ok: true });

    const chatId = msg.chat?.id;
    const username: string | null = msg.chat?.username || null;
    const firstName: string | null = msg.chat?.first_name || null;
    const text: string = msg.text || '';

    if (typeof text === 'string' && text.trim().toLowerCase().startsWith('/start')) {
      const pool = getPool();
      const client = await pool.connect();
      try {
        await client.query('BEGIN');

        if (username) {
          await client.query(
            `
            INSERT INTO telegram_users (username, chat_id, first_name, created_at, updated_at)
            VALUES ($1, $2, $3, NOW(), NOW())
            ON CONFLICT (username)
            DO UPDATE SET chat_id = EXCLUDED.chat_id, first_name = EXCLUDED.first_name, updated_at = NOW()
          `,
            [username, chatId, firstName]
          );
        } else {
          await client.query(
            `
            INSERT INTO telegram_users (username, chat_id, first_name, created_at, updated_at)
            VALUES ($1, $2, $3, NOW(), NOW())
            ON CONFLICT (username) DO NOTHING
          `,
            [`chat_${chatId}`, chatId, firstName]
          );
        }

        await client.query('COMMIT');
      } catch (e) {
        await client.query('ROLLBACK');
        throw e;
      } finally {
        client.release();
      }

      await sendTelegramMessage(
        chatId,
        `âœ… Thanks${
          firstName ? `, <b>${firstName}</b>` : ''
        }! Your Telegram is now linked.\n\nYou can return to the form and click <b>Verify</b>.`
      );
    }

    return NextResponse.json({ ok: true });
  } catch (e: unknown) {
    return NextResponse.json({ ok: false, error: e instanceof Error ? e.message : 'webhook error' }, { status: 200 });
  }
}

export async function GET() {
  return NextResponse.json({ ok: true, route: 'telegram-webhook' });
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\upload\route.ts
================================================================================

import { NextRequest, NextResponse } from 'next/server';
import { saveBuffer, getFilePath } from '@/lib/fileStorage';
import { randomUUID } from 'crypto';
import JSZip from 'jszip';
import { makeImagePreview } from '@/lib/preview';

export const runtime = 'nodejs';

export async function POST(req: NextRequest) {
  const form = await req.formData();
  const file = form.get('file') as File | null;
  const smartDetection = form.get('smartDetection') === 'true';
  
  if (!file) return NextResponse.json({ error: 'file required' }, { status: 400 });

  const arrayBuf = await file.arrayBuffer();
  const buf = Buffer.from(arrayBuf);

  if ((file.type || '').includes('zip') || /\.zip$/i.test(file.name)) {
    const zipId = randomUUID();
    // Smart ZIP detection implemented in /api/analyze-zip route
    // â”œâ”€â”€ css/
    // â”‚   â””â”€â”€ styles.css
    // â””â”€â”€ js/
    //     â””â”€â”€ script.js
    // 
    // OR:
    // â”œâ”€â”€ creative.html
    // â”œâ”€â”€ background.jpg
    // â”œâ”€â”€ logo.png
    // â””â”€â”€ styles.css
    // 
    // MULTIPLE CREATIVE EXAMPLES:
    // â”œâ”€â”€ creative1/
    // â”‚   â”œâ”€â”€ index.html
    // â”‚   â””â”€â”€ images/
    // â”œâ”€â”€ creative2/
    // â”‚   â”œâ”€â”€ main.html
    // â”‚   â””â”€â”€ assets/
    // â””â”€â”€ creative3/
    //     â””â”€â”€ landing.html
    // 
    // OR:
    // â”œâ”€â”€ banner-300x250.html
    // â”œâ”€â”€ banner-728x90.html
    // â”œâ”€â”€ banner-160x600.html
    // â””â”€â”€ shared-assets/
    // 
    // RESPONSE FORMAT:
    // 
    // For Single Creative:
    // {
    //   "success": true,
    //   "zipAnalysis": {
    //     "isSingleCreative": true,
    //     "mainCreative": {
    //       "fileId": "abc123",
    //       "fileName": "index.html",
    //       "fileUrl": "/api/uploads?id=abc123&name=index.html",
    //       "fileSize": 2048,
    //       "fileType": "text/html",
    //       "previewUrl": "/api/uploads?id=preview123&name=preview.jpg"
    //     },
    //     "assetCount": 5,
    //     "assetTypes": ["image", "stylesheet", "script"],
    //     "totalSize": 50000,
    //     "structure": "single-with-assets"
    //   }
    // }
    // 
    // For Multiple Creatives:
    // {
    //   "success": true,
    //   "zipAnalysis": {
    //     "isSingleCreative": false,
    //     "creativeCount": 3,
    //     "structure": "multiple-separate",
    //     "recommendation": "use-multiple-upload-flow"
    //   }
    // }
    // 
    // EDGE CASES TO HANDLE:
    // 1. ZIP with only images (no HTML) - treat as single creative assets
    // 2. ZIP with HTML fragments/includes - analyze for main file
    // 3. ZIP with mixed content - prioritize clear creative structure
    // 4. ZIP with nested directories - analyze depth and structure
    // 5. ZIP with external dependencies - maintain asset references
    // 
    // PERFORMANCE CONSIDERATIONS:
    // 1. Stream ZIP analysis without full extraction
    // 2. Cache analysis results for duplicate uploads
    // 3. Limit analysis to first 100 files for large ZIPs
    // 4. Timeout protection for complex analysis
    // 
    // IMPLEMENTATION PRIORITY:
    // 1. Implement basic HTML file counting
    // 2. Add directory structure analysis
    // 3. Implement asset categorization
    // 4. Add smart detection logic
    // 5. Handle edge cases and optimization
    
    if (smartDetection) {
      // Smart ZIP detection implementation
      const JSZip = (await import("jszip")).default;
      const sharp = (await import("sharp")).default;
      const path = await import("path");
      const fs = await import("fs/promises");

      const normalize = (p: string) =>
        p.replace(/\\/g, "/").replace(/\.\.(\/|\\)/g, "").replace(/^\/+/, "");

      const writeFile = async (relPath: string, data: Buffer) => {
        const abs = await getFilePath(zipId, relPath);
        await fs.mkdir(path.dirname(abs), { recursive: true });
        await fs.writeFile(abs, data);
        return abs;
      };

      const zip = await JSZip.loadAsync(buf);
      const entries = Object.values(zip.files).filter((f) => !f.dir);

      const items: Array<{
        id: string;
        name: string;
        type: "image" | "html" | "other";
        size: number;
        url: string;
        previewUrl?: string;
        html?: boolean;
      }> = [];

      let images = 0, htmls = 0, others = 0;

      for (const entry of entries) {
        const rel = normalize(entry.name);
        if (!rel) continue;

        const ext = rel.split(".").pop()?.toLowerCase() || "";
        const isImage = ["png", "jpg", "jpeg", "gif", "webp"].includes(ext);
        const isHtml = ["html", "htm"].includes(ext);

        const data = Buffer.from(await entry.async("nodebuffer"));
        await writeFile(rel, data);

        const baseUrl = `/api/files/${encodeURIComponent(zipId)}/`;
        const url = baseUrl + rel;

        const item: {
          id: string;
          name: string;
          type: "image" | "html" | "other";
          size: number;
          url: string;
          previewUrl?: string;
          html?: boolean;
        } = {
          id: zipId,
          name: rel,
          type: isImage ? "image" : isHtml ? "html" : "other",
          size: data.length,
          url,
        };
        if (isHtml) item.html = true;

        if (isImage) {
          try {
            const thumbRel = `thumbs/${rel.replace(/\//g, "__")}.jpg`;
            const thumb = await sharp(data)
              .resize(480, 480, { fit: "inside", withoutEnlargement: true })
              .jpeg({ quality: 80 })
              .toBuffer();
            await writeFile(thumbRel, thumb);
            item.previewUrl = baseUrl + thumbRel;
          } catch {
            item.previewUrl = url;
          }
        }

        items.push(item);
        if (isImage) images++;
        else if (isHtml) htmls++;
        else others++;
      }

      // Heuristic: treat as single if exactly one main creative (1 HTML or 1 image)
      const mainCount = items.filter(i => i.type === "html" || i.type === "image").length;
      const isSingleCreative = mainCount === 1;

      return NextResponse.json({
        uploadId: zipId,
        isSingleCreative,
        items,
        counts: { images, htmls, others, total: items.length },
      });
    }
    
    const zip = await JSZip.loadAsync(buf);
    // Image preview generation implemented with thumbnail support

    const extractedFiles: Array<{
      fileId: string;
      fileName: string;
      fileUrl: string;
      fileSize: number;
      fileType: string;
      originalPath: string;
      previewUrl?: string; // Image preview generation implemented
    }> = [];
    const entries = Object.values(zip.files);
    for (const entry of entries) {
      if (entry.dir) continue;
      const content = await entry.async('nodebuffer');
      const saved = await saveBuffer(content, entry.name);
      
      const fileType = guessType(entry.name);
      const isImage = /\.(jpg|jpeg|png|gif|webp)$/i.test(entry.name);
      
      let previewUrl: string | undefined;
      if (isImage) {
        try {
          const thumb = await makeImagePreview(content, 400);
          if (thumb) {
            const prev = await saveBuffer(thumb, `preview_${saved.fileName}.jpg`);
            previewUrl = `/api/files/${prev.id}/${encodeURIComponent(prev.fileName)}`;
          }
        } catch (error) {
          console.error('Thumbnail generation failed:', error);
        }
      }

      extractedFiles.push({
        fileId: saved.id,
        fileName: entry.name.split('/').pop() || entry.name,
        fileUrl: `/api/files/${saved.id}/${encodeURIComponent(saved.fileName)}`,
        fileSize: content.length,
        fileType: fileType,
        originalPath: entry.name,
        previewUrl
      });
    }
    return NextResponse.json({
      success: true,
      zipFileId: zipId,
      extractedFiles,
      totalFiles: extractedFiles.length,
      extractionDate: new Date().toISOString()
    });
  }

  const saved = await saveBuffer(buf, file.name);
  const fileUrl = `/api/files/${saved.id}/${encodeURIComponent(saved.fileName)}`;

  let previewUrl: string | undefined;
  if (/\.(jpg|jpeg|png|gif|webp)$/i.test(file.name)) {
    const thumb = await makeImagePreview(buf, 400);
    if (thumb) {
      const prev = await saveBuffer(thumb, `preview_${saved.fileName}.jpg`);
      previewUrl = `/api/files/${prev.id}/${encodeURIComponent(prev.fileName)}`;
    }
  }

  return NextResponse.json({
    success: true,
    file: {
      fileId: saved.id,
      fileName: saved.fileName,
      fileUrl,
      fileSize: buf.length,
      fileType: file.type || guessType(file.name),
      uploadDate: new Date().toISOString(),
      previewUrl
    }
  });
}

function guessType(name: string) {
  const n = name.toLowerCase();
  if (/\.(png|jpg|jpeg|gif|webp)$/.test(n)) return 'image/' + n.split('.').pop();
  if (/\.html?$/.test(n)) return 'text/html';
  return 'application/octet-stream';
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\upload-progress\route.ts
================================================================================

import { NextResponse } from 'next/server';
import { progressGet } from '@/lib/progressStore';

export const dynamic = 'force-dynamic';

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const id = searchParams.get('id');
  if (!id) return NextResponse.json({ error: 'Missing id' }, { status: 400 });

  const state = progressGet(id);
  if (!state) return NextResponse.json({ status: 'unknown', pct: 0 }, { status: 200 });

  return NextResponse.json(state);
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\uploads\route.ts
================================================================================


import { NextRequest } from 'next/server';
import { getFilePath } from '@/lib/fileStorage';
import { createReadStream } from 'fs';
import { stat } from 'fs/promises';

export async function GET(req: NextRequest) {
  const id = req.nextUrl.searchParams.get('id');
  const name = req.nextUrl.searchParams.get('name');
  if (!id || !name) return new Response('missing id/name', { status: 400 });

  const p = await getFilePath(id, name);
  try {
    await stat(p);
  } catch {
    return new Response('not found', { status: 404 });
  }

  // Determine content type based on file extension
  const ext = name.toLowerCase().split('.').pop();
  let contentType = 'application/octet-stream';
  
  if (ext === 'html' || ext === 'htm') {
    contentType = 'text/html; charset=utf-8';
  } else if (ext === 'css') {
    contentType = 'text/css';
  } else if (ext === 'js') {
    contentType = 'application/javascript';
  } else if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext || '')) {
    contentType = `image/${ext === 'jpg' ? 'jpeg' : ext}`;
  }

  const stream = createReadStream(p);
  return new Response(stream as unknown as ReadableStream, {
    headers: {
      'Content-Type': contentType,
      'Cache-Control': 'public, max-age=3600',
    },
  });
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\upload-url\route.ts
================================================================================

import { NextResponse } from 'next/server';
import { detectFileType } from '@/lib/security/fileType';
import { scanBufferWithClamAV } from '@/lib/security/clamav';
import { sha256 } from '@/lib/security/checksums';
import { sendToLoggingService } from '@/lib/logging';
import { rateLimit } from '@/lib/rateLimit';
import { quarantineBuffer } from '@/lib/quarantine';
import { makeImagePreview, makeBasicTextPreview } from '@/lib/preview';
import { maybeConvert } from '@/lib/conversion';
import { saveBuffer } from '@/lib/fileStorage';
import { progressStart, progressUpdate, progressDone, progressError } from '@/lib/progressStore';


const ALLOW = new Set([
  'image/png','image/jpeg','image/gif','image/webp','image/svg+xml',
  'text/html','application/pdf','application/zip','application/vnd.openxmlformats-officedocument.wordprocessingml.document'
]);
const PER_TIER_MAX: Record<string, number> = {
  free: 20 * 1024 * 1024,
  pro: 200 * 1024 * 1024,
  enterprise: 2 * 1024 * 1024 * 1024,
};
const REQUIRE_SCAN = process.env.REQUIRE_VIRUS_SCAN === '1';
const ENABLE_SCAN  = process.env.ENABLE_VIRUS_SCAN === '1';
const ENABLE_CONVERSION = process.env.ENABLE_IMAGE_CONVERSION === '1';

function getClientKey(req: Request) {
  const ip = (req.headers.get('x-forwarded-for') || '').split(',')[0].trim() || 'unknown-ip';
  const uid = req.headers.get('x-user-id') || 'anon';
  return `${uid}:${ip}`;
}
function getUserTier(req: Request): keyof typeof PER_TIER_MAX {
  const t = (req.headers.get('x-user-tier') || 'free') as keyof typeof PER_TIER_MAX;
  return PER_TIER_MAX[t] ? t : 'free';
}

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const key = getClientKey(req);
  if (!rateLimit(key, { capacity: 20, refillPerSec: 0.5 })) {
    return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 });
  }

  const form = await req.formData();
  const file = form.get('file') as File | null;
  if (!file) return NextResponse.json({ error: 'No file provided' }, { status: 400 });

  const uploadId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  progressStart(uploadId, { type: 'single', name: file.name, size: file.size });
  
  try {
    progressUpdate(uploadId, 5, 'reading');

    const tier = getUserTier(req);
    const maxSize = PER_TIER_MAX[tier];

    const ab = await file.arrayBuffer();
    const buf = Buffer.from(ab);
    if (buf.length > maxSize) {
      progressError(uploadId, `File exceeds tier limit (${tier})`, 5);
      return NextResponse.json({ error: `File exceeds tier limit (${tier})` }, { status: 413 });
    }

    progressUpdate(uploadId, 15, 'validating');
    const detected = await detectFileType(buf, file.name);
    if (!ALLOW.has(detected.mime)) {
      await sendToLoggingService({ event: 'disallowed-mime', mime: detected.mime, name: file.name });
      progressError(uploadId, `Unsupported MIME type: ${detected.mime}`, 15);
      return NextResponse.json({ error: `Unsupported MIME type: ${detected.mime}` }, { status: 415 });
    }

    progressUpdate(uploadId, 25, 'processing');
    let working = buf;
    let effectiveMime = detected.mime;
    if (ENABLE_CONVERSION) {
      const conv = await maybeConvert(buf, detected.mime);
      working = Buffer.from(conv.buffer); effectiveMime = conv.mime;
    }

    progressUpdate(uploadId, 40, 'scanning');
    if (ENABLE_SCAN || REQUIRE_SCAN) {
      const verdict = await scanBufferWithClamAV(working);
      if (verdict === 'UNAVAILABLE') {
        if (REQUIRE_SCAN) {
          progressError(uploadId, 'Virus scanner unavailable', 40);
          return NextResponse.json({ error: 'Virus scanner unavailable' }, { status: 503 });
        }
      } else if (verdict !== 'OK') {
        await quarantineBuffer(working, file.name, `scan-${verdict}`);
        await sendToLoggingService({ event: 'virus-detected', verdict, name: file.name });
        progressError(uploadId, 'File failed virus scanning', 40);
        return NextResponse.json({ error: 'File failed virus scanning' }, { status: 422 });
      }
    }

    progressUpdate(uploadId, 60, 'generating checksum');
    const hash = sha256(working);

    progressUpdate(uploadId, 70, 'saving');
    const { id, fileName } = await saveBuffer(working, file.name);
    const fileUrl = `/api/files/${id}/${fileName}`;

    progressUpdate(uploadId, 85, 'generating preview');
    let previewUrl: string | null = null;
    try {
      if (effectiveMime.startsWith('image/')) {
        const thumb = await makeImagePreview(working);
        if (thumb) {
          const thumbSave = await saveBuffer(thumb, `preview_${file.name}.jpg`);
          previewUrl = `/api/files/${thumbSave.id}/${thumbSave.fileName}`;
        }
      } else if (effectiveMime === 'text/html') {
        const txt = await makeBasicTextPreview(working, 2048);
        const previewBuf = Buffer.from(txt as string, 'utf8');
        const prev = await saveBuffer(previewBuf, `preview_${file.name}.txt`);
        previewUrl = `/api/files/${prev.id}/${prev.fileName}`;
      }
    } catch (e) {
      await sendToLoggingService({ event: 'preview-failed', error: (e as Error).message, name: file.name });
    }

    progressDone(uploadId, { url: fileUrl });
    return NextResponse.json({
      uploadId,
      url: fileUrl,
      key: `${id}/${fileName}`,
      mime: effectiveMime,
      hash,
      previewUrl,
      tier,
    });
  } catch (e) {
    progressError(uploadId, (e as Error).message || 'Upload failed', 0);
    return NextResponse.json({ error: 'Upload failed', detail: (e as Error).message, uploadId }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\upload-zip\route.ts
================================================================================

import { NextResponse } from 'next/server';
import { detectFileType } from '@/lib/security/fileType';
import { previewZipCentralDirectory } from '@/lib/zipPreview';
import { processZipBuffer } from '@/lib/zip';
import { extractEncryptedZipBuffer } from '@/lib/zipPassword';
import { sendToLoggingService } from '@/lib/logging';
import { rateLimit } from '@/lib/rateLimit';
import { progressStart, progressUpdate, progressDone, progressError } from '@/lib/progressStore';

const ALLOW = new Set([
  'image/png','image/jpeg','image/gif','image/webp','image/svg+xml',
  'text/html','application/pdf',
]);
const MAX_FILES = Number(process.env.ZIP_MAX_FILES ?? 200);
const MAX_TOTAL = Number(process.env.ZIP_MAX_TOTAL ?? 300 * 1024 * 1024);
const MAX_DEPTH = Number(process.env.ZIP_MAX_DEPTH ?? 2);
const PER_FILE_MAX = Number(process.env.ZIP_PER_FILE_MAX ?? 50 * 1024 * 1024);
const ENABLE_SCAN = process.env.ENABLE_VIRUS_SCAN === '1';
const ENCRYPTED_POLICY: 'skip' | 'error' | 'attempt' = (process.env.ZIP_ENCRYPTED_POLICY as 'skip' | 'error' | 'attempt') ?? 'skip';

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const ip = (req.headers.get('x-forwarded-for') || '').split(',')[0].trim() || 'unknown-ip';
  if (!rateLimit(`zip:${ip}`, { capacity: 10, refillPerSec: 0.2 })) {
    return NextResponse.json({ error: 'Rate limit exceeded' }, { status: 429 });
  }

  const form = await req.formData();
  const file = form.get('file') as File | null;
  if (!file) return NextResponse.json({ error: 'No file' }, { status: 400 });

  const uploadId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  progressStart(uploadId, { name: file.name, size: file.size });
  
  try {
    progressUpdate(uploadId, 1, 'reading');

    const ab = await file.arrayBuffer();
    const buf = Buffer.from(ab);

    const head = await detectFileType(buf, file.name);
    if (head.mime !== 'application/zip') {
      progressError(uploadId, 'Not a ZIP', 0);
      return NextResponse.json({ error: 'Not a ZIP archive' }, { status: 415 });
    }

    progressUpdate(uploadId, 5, 'previewing');
    const preview = previewZipCentralDirectory(buf);
    if (!preview) {
      progressError(uploadId, 'EOCD not found', 5);
      return NextResponse.json({ error: 'Failed to parse ZIP (EOCD not found)' }, { status: 422 });
    }

    const encryptedEntries = preview.entries.filter(e => e.encrypted && !e.isDirectory);
    const hasEncrypted = encryptedEntries.length > 0;
    const compression = {
      totalCompressedBytes: preview.totals.compressed,
      totalUncompressedBytes: preview.totals.uncompressed,
      overallCompressionRatio: preview.totals.overallRatio,
      entryCount: preview.totals.files + preview.totals.dirs,
      highExpansionEntries: preview.suspicious.highExpansionEntries,
      highOverallExpansion: preview.suspicious.highOverallExpansion,
    };

    const extracted: Array<{
      fileId: string;
      fileName: string;
      fileUrl: string;
      fileSize: number;
      fileType: string;
      hash: string;
      depth: number;
      encrypted?: boolean;
    }> = [];
    const skipped: Array<{
      path?: string;
      reason: string;
    }> = [];

    
    const password = req.headers.get('x-zip-password') || undefined;
    if (hasEncrypted) {
      if (ENCRYPTED_POLICY === 'error') {
        progressError(uploadId, 'Encrypted entries present', 10);
        return NextResponse.json({
          error: 'ZIP contains password-protected entries',
          encryptedEntries: encryptedEntries.map(e => e.name),
          compression, uploadId
        }, { status: 422 });
      }
      if (ENCRYPTED_POLICY === 'attempt' && password) {
        progressUpdate(uploadId, 12, 'decrypting encrypted entries');
        const dec = await extractEncryptedZipBuffer(buf, password, {
          allow: ALLOW, enableVirusScan: ENABLE_SCAN, perFileMaxBytes: PER_FILE_MAX
        });
        extracted.push(...dec.extracted);
        skipped.push(...dec.skipped);
      } else if (ENCRYPTED_POLICY === 'skip') {
        skipped.push(...encryptedEntries.map(e => ({ path: e.name, reason: 'encrypted' })));
      }
    }

    progressUpdate(uploadId, 15, 'extracting safe entries');
    const safe = await processZipBuffer(buf, {
      allow: ALLOW,
      maxFiles: MAX_FILES,
      maxTotalBytes: MAX_TOTAL,
      maxDepth: MAX_DEPTH,
      perFileMaxBytes: PER_FILE_MAX,
      enableVirusScan: ENABLE_SCAN,
      deduplicate: true,
      
      onEntry: ({ path, index, total }) => {
        if (index % 5 === 0) progressUpdate(uploadId, Math.min(90, Math.round(15 + (index / Math.max(1, total)) * 70)), `processing: ${path}`);
      },
      onProgress: (pct) => progressUpdate(uploadId, Math.min(95, pct), 'processing')
    });

    extracted.push(...safe.extracted);
    skipped.push(...safe.skipped);

    progressUpdate(uploadId, 97, 'finalizing');
    await sendToLoggingService({
      event: 'zip-complete',
      uploadId, extractedCount: extracted.length, skippedCount: skipped.length, totals: compression
    });

    progressDone(uploadId, { extractedCount: extracted.length, skippedCount: skipped.length });
    return NextResponse.json({
      uploadId, preview, compression,
      extractedFiles: extracted, skipped, totalBytes: safe.totalBytes
    });
  } catch (e) {
    progressError(uploadId, (e as Error).message || 'unknown', 0);
    return NextResponse.json({ error: 'ZIP processing failed', detail: (e as Error).message, uploadId }, { status: 500 });
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\api\zip\preview\route.ts
================================================================================

import { NextResponse } from 'next/server';
import { previewZipCentralDirectory } from '@/lib/zipPreview';
import { detectFileType } from '@/lib/security/fileType';

export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  const form = await req.formData();
  const file = form.get('file') as File | null;
  if (!file) return NextResponse.json({ error: 'No file provided' }, { status: 400 });

  const ab = await file.arrayBuffer();
  const buf = Buffer.from(ab);

  const head = await detectFileType(buf, file.name);
  if (head.mime !== 'application/zip') {
    return NextResponse.json({ error: 'Not a ZIP archive' }, { status: 415 });
  }

  const preview = previewZipCentralDirectory(buf, { maxEntries: 2000 });
  if (!preview) return NextResponse.json({ error: 'Failed to parse ZIP (EOCD not found)' }, { status: 422 });

  return NextResponse.json({ preview });
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\Constants\Constants.ts
================================================================================


export const Constants = {
    logo: "/Logo.svg",
    background: "/Background.svg",

    // Form Constants
    formTitle: "Submit Your Creatives For Approval",
    formDescription: "Upload your static images or HTML creatives with offer details to begin the approval process. Our team will review and notify you shortly.",

    // Form Fields
    formFields: [
        {
            label: "Affiliate ID",
            name: "affiliateId",
            type: "text",
            placeholder: "Enter Affiliate ID",
        },
        {
            label: "Company Name",
            name: "companyName",
            type: "text",
            placeholder: "Enter Company Name",
        },
        {
            label: "First Name",
            name: "firstName",
            type: "text",
            placeholder: "Enter First Name",
        },
        {
            label: "Last Name",
            name: "lastName",
            type: "text",
            placeholder: "Enter Last Name",
        },
        {
            label: "Email",
            name: "email",
            type: "email",
            placeholder: "Enter Email",
        },
        {
            label: "Telegram ID (Optional)",
            name: "telegramId",
            type: "text",
            placeholder: "Enter Telegram ID",
        },
        {
            label: "Offer ID",
            name: "offerId",
            type: "select",
            options: [
                { label: "Loading offers...", value: "loading" },
            ],
            placeholder: "Select Offer",
        },
        {
            label: "Creative Type",
            name: "creativeType",
            type: "select",
            options: [
                { label: "Email", value: "email" },
                { label: "Display", value: "display" },
                { label: "Search", value: "search" },
                { label: "Social", value: "social" },
                { label: "Native", value: "native" },
                { label: "Push", value: "push" },
            ],
            placeholder: "Select Creative Type",
        },
        {
            label: "Additional Notes or Requests for Client",
            name: "additionalNotes",
            type: "textarea",
            placeholder: "Enter Additional Notes or Requests for Client",
        },
        {
            label: "From Lines",
            name: "fromLines",
            type: "textarea",
            placeholder: "Enter From Lines",
        },
        {
            label: "Subject Lines",
            name: "subjectLines",
            type: "textarea",
            placeholder: "Enter Subject Lines",
        },
    ],

    // Upload Creative Types
    uploadCreativeTypes: [ 
        { label: "Single Creative", value: "singleCreative" },
        { label: "Multiple Creatives", value: "multipleCreatives" },
        { label: "From & Subject Lines", value: "fromSubjectLines" },
    ],

    // Button Texts
    buttonTexts: {
        next: "Next",
        previous: "Previous",
        submit: "Submit Creative",
        loading: "Loading...",
        verifying: "Verifying...",
        verify: "Verify",
        verified: "Verified",
        startBot: "Start Bot",
        nextStep2: "Save & Add Contact Details",
        prevStep1: "Edit Personal Details",
        nextStep3: "Save & Add Creative Details",
        prevStep2: "Edit Contact Details",
    },

    // Step Labels
    stepLabels: {
        step1: "Personal Details",
        step2: "Contact Details", 
        step3: "Creative Details",
    },

    // Current Step
    currentStep: [
        {
            stepNumber: 1,
            stepLabel: "Personal Details",
        },
        {
            stepNumber: 2,
            stepLabel: "Contact Details",
        },
        {
            stepNumber: 3,
            stepLabel: "Creative Details",
        },
    ],
    
    totalSteps: 3,

    // Verification Steps
    verificationSteps: [
        "Click on Start Bot Button",
        "Send /start to the bot",
        "Come back and Verify again",
    ],

    // From & Subject Lines Configuration
    fromSubjectLinesConfig: {
        title: "From & Subject Lines",
        description: "Enter compelling from lines and subject lines for your email campaigns",
        guidelines: {
            title: "Email Content Guidelines:",
            items: [
                "From Lines: Enter the sender name/email that will appear in the \"From\" field",
                "Subject Lines: Enter compelling subject lines to improve email open rates",
                "Multiple Lines: You can enter multiple options separated by line breaks",
                "Best Practices: Keep subject lines under 50 characters for better display"
            ]
        },
        fromLines: {
            label: "From Lines *",
            placeholder: "Enter from lines",
            helpText: "Enter multiple from lines separated by line breaks. Each line will be used as an option.",
            required: true
        },
        subjectLines: {
            label: "Subject Lines *",
            placeholder: "Enter subject lines",
            helpText: "Enter multiple subject lines separated by line breaks. Each line will be used as an option.",
            required: true
        },
        buttons: {
            save: "Save Lines",
            cancel: "Cancel"
        },
        characterCount: {
            fromLines: "From Lines: {count} characters",
            subjectLines: "Subject Lines: {count} characters"
        }
    },

    // Prority
    priorityLevels: [
        { name: "High", value: "high" },
        { name: "Medium", value: "medium" },
    ]
} 



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\Form\CreativeForm.tsx
================================================================================

"use client"

import React, { useState } from 'react'
import { Constants } from '@/app/Constants/Constants'
import Image from 'next/image'
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import { Separator } from '@/components/ui/separator'
import { Button } from '@/components/ui/button'
import PersonalDetails from '@/app/Form/Steps/PersonalDetails'
import ContactDetails from '@/app/Form/Steps/ContactDetails'
import CreativeDetails from '@/app/Form/Steps/CreativeDetails'

type FileMeta = { 
  id: string; 
  name: string; 
  url: string; 
  size: number; 
  type: string; 
  source?: 'single'|'zip'; 
  html?: boolean 
};

const CreativeForm = () => {
  const [currentStep, setCurrentStep] = useState(1)
  
  const [files, setFiles] = useState<FileMeta[]>([])
  
  const [formData, setFormData] = useState({
    affiliateId: '',
    companyName: '',
    firstName: '',
    lastName: '',
    
    // Contact Details
    email: '',
    telegramId: '',
    
    // Creative Details
    offerId: '',
    creativeType: '',
    additionalNotes: '',
    fromLines: '',
    subjectLines: '',
    priority: 'medium',
    
    // Files (will be populated by upload handlers)
    uploadedFiles: [] as Array<{
      fileId: string;
      fileName: string;
      fileUrl: string;
      fileSize: number;
      fileType: string;
    }>
  })
  
  const [isSubmitting, setIsSubmitting] = useState(false)

  const handleNext = () => {
    if (currentStep < Constants.totalSteps) {
      setCurrentStep(currentStep + 1)
    }
  }
  
  const handleFormDataChange = (stepData: Partial<typeof formData>) => {
    setFormData(prev => ({ ...prev, ...stepData }))
  }
  
  const handleSubmit = async () => {
    if (currentStep !== Constants.totalSteps) return
    
    setIsSubmitting(true)
    try {
      const response = await fetch('/api/creative/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          affiliateId: formData.affiliateId,
          companyName: formData.companyName,
          firstName: formData.firstName,
          lastName: formData.lastName,
          email: formData.email,
          telegramId: formData.telegramId,
          offerId: formData.offerId,
          creativeType: formData.creativeType,
          fromLines: formData.fromLines,
          subjectLines: formData.subjectLines,
          notes: formData.additionalNotes,
          priority: formData.priority,
          files: files.map(f => ({
            fileName: f.name,
            fileUrl: f.url,
            fileType: f.type,
            fileSize: f.size
          }))
        })
      })
      
      if (response.ok) {
        const result = await response.json()
        console.log('Creative saved successfully:', result)
      } else {
        throw new Error('Failed to save creative')
      }
    } catch (error) {
      console.error('Submission failed:', error)
    } finally {
      setIsSubmitting(false)
    }
  }

  const handlePrev = () => {
    if (currentStep > 1) {
      setCurrentStep(currentStep - 1)
    }
  }

  const getStepContent = () => {
    switch (currentStep) {
      case 1:
        return (
          <PersonalDetails 
            formData={formData}
            onDataChange={handleFormDataChange}
          />
        )
      case 2:
        return (
          <ContactDetails 
            formData={formData}
            onDataChange={handleFormDataChange}
          />
        )
              case 3:
          return (
            <CreativeDetails 
              formData={formData}
              onDataChange={handleFormDataChange}
              onFilesChange={setFiles}
            />
          )
      default:
        return <div>Step not found</div>
    }
  }

  const getStepLabel = () => {
    return Constants.currentStep.find(step => step.stepNumber === currentStep)?.stepLabel || ''
  }

  const getButtonText = () => {
    if (currentStep === 1) {
      return { prev: 'Back', next: Constants.buttonTexts.nextStep2 }
    } else if (currentStep === 2) {
      return { prev: Constants.buttonTexts.prevStep1, next: Constants.buttonTexts.nextStep3 }
    } else {
      return { prev: Constants.buttonTexts.prevStep2, next: Constants.buttonTexts.submit }
    }
  }

  return (
    <div className="flex flex-col items-center min-h-screen py-8 px-4" 
    style={{
        backgroundImage: `url(${Constants.background})`,
        backgroundColor: "var(--color-primary-50)",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center",
        backgroundSize: "cover",
    }}
    >
        <div className="flex flex-col items-center justify-center mb-8">
            <Image src={Constants.logo} alt='logo' width={100} height={100} className="w-40 md:w-60 h-10 md:h-20"/>
        </div>

        <Card className="w-full max-w-3xl mx-auto shadow-xl">
            <CardHeader>
                <CardTitle className="text-2xl sm:text-4xl font-bold text-heading">{Constants.formTitle}</CardTitle>
                <CardDescription className="text-base sm:text-lg text-body leading-relaxed py-4">{Constants.formDescription}</CardDescription>
                <div>
                    <p className="text-base sm:text-lg font-semibold text-primary-500">Step {currentStep} of {Constants.totalSteps} : {getStepLabel()}</p>
                </div>
                <Separator className="mt-4" />
            </CardHeader>
            <CardContent>
                {getStepContent()}
            </CardContent>
            <CardFooter>
                            <div className="flex flex-col justify-between gap-4 w-full">
                {currentStep > 1 && (
                    <Button 
                        variant="outline" 
                        className="w-full" 
                        onClick={handlePrev}
                    >
                        {getButtonText().prev}
                    </Button>
                )}
                <Button 
                    className="w-full" 
                    onClick={currentStep === Constants.totalSteps ? handleSubmit : handleNext}
                    disabled={isSubmitting}
                >
                    {isSubmitting ? 'Submitting...' : getButtonText().next}
                </Button>
            </div>
            </CardFooter>
        </Card>
    </div>
  )
}

export default CreativeForm



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\Form\Steps\ContactDetails.tsx
================================================================================

import { Constants } from '@/app/Constants/Constants'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import React, { useState } from 'react'
import { TELEGRAM_BOT_URL } from '@/constants'

interface ContactDetailsProps {
  formData: {
    email: string;
    telegramId: string;
  };
  onDataChange: (data: Partial<ContactDetailsProps['formData']>) => void;
}

const ContactDetails: React.FC<ContactDetailsProps> = ({ formData, onDataChange }) => {
  
  const [isTelegramFocused, setIsTelegramFocused] = useState(false)
  const [isVerifying, setIsVerifying] = useState(false)
  const [isVerified, setIsVerified] = useState(false)
  const [verificationAttempted, setVerificationAttempted] = useState(false)

const contactFields = Constants.formFields.filter(field =>
  ['email', 'telegramId'].includes(field.name)
)

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const { name, value } = e.target
  
  // Special handling for Telegram ID field
  if (name === 'telegramId') {
    let processedValue = value
    
    // If user is typing and value doesn't start with @, add it
    if (value && !value.startsWith('@')) {
      processedValue = '@' + value
    }
    
    // If user deletes everything, don't add @
    if (value === '') {
      processedValue = ''
    }
    
    onDataChange({ [name]: processedValue })
  } else {
    // Normal handling for other fields
    onDataChange({ [name]: value })
  }
}

const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
  const { name, value } = e.currentTarget
  
  // Handle backspace for Telegram field
  if (name === 'telegramId' && e.key === 'Backspace') {
    // If current value is just "@" and user presses backspace, prevent deletion
    if (value === '@') {
      e.preventDefault()
      return
    }
    
    // If user is trying to delete the "@" symbol, prevent it
    if (value.length === 2 && value.startsWith('@')) {
      e.preventDefault()
      onDataChange({ [name]: '@' })
      return
    }
  }
}

const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
  const { name } = e.target
  
  // Track focus state for Telegram field
  if (name === 'telegramId') {
    setIsTelegramFocused(true)
    
    // Add @ when focusing on Telegram field if it's empty
    if (!formData.telegramId) {
      onDataChange({ [name]: '@' })
    }
  }
}

const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
  const { name, value } = e.target
  
  // Track focus state for Telegram field
  if (name === 'telegramId') {
    setIsTelegramFocused(false)
    
    // Remove @ when losing focus if user hasn't entered anything meaningful
    if (value === '@' || value === '') {
      onDataChange({ [name]: '' })
    }
  }
}

const handleVerify = async () => {
  if (!formData.telegramId || formData.telegramId === '@') return
  
  setIsVerifying(true)
  setVerificationAttempted(true)
  
  try {
    await fetch('/api/telegram/poll', { method: 'POST' })

    const res = await fetch('/api/telegram/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ telegramId: formData.telegramId }),
    })
    
    if (!res.ok) {
      throw new Error('Verification request failed')
    }
    
    const data = await res.json()
    setIsVerified(Boolean(data.verified))
  } catch (err) {
    console.error('Verification failed:', err)
    setIsVerified(false)
  } finally {
    setIsVerifying(false)
  }
}

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        {contactFields.map((field) => (
          <div key={field.name} className="space-y-2">
            <Label htmlFor={field.name}>{field.label}</Label>
            
            {/* Custom input container for Telegram field with verify button */}
            {field.name === 'telegramId' ? (
              <div className="relative">
                <Input 
                  id={field.name}
                  name={field.name}
                  type={field.type}
                  placeholder={field.placeholder}
                  value={formData[field.name as keyof typeof formData]}
                  onChange={handleChange}
                  onFocus={handleFocus}
                  onBlur={handleBlur}
                  onKeyDown={handleKeyDown}
                  className="pr-20" // Add right padding for the button
                />
                <Button
                  variant="outline"
                  size="sm"
                  type="button"
                  onClick={handleVerify}
                  disabled={isVerifying || isVerified || !formData.telegramId || formData.telegramId === '@'}
                  className="absolute right-2 top-1/2 transform -translate-y-1/2 h-8 px-3 text-xs"
                >
                  {isVerifying ? (
                    <div className="flex items-center gap-2">
                      <div className="w-3 h-3 border-2 border-primary-500 border-t-transparent rounded-full animate-spin"></div>
                      <span>Verifying...</span>
                    </div>
                  ) : isVerified ? (
                    <div className="flex items-center gap-2 text-success-dark">
                      <span>âœ…</span>
                      <span>Verified</span>
                    </div>
                  ) : (
                    'Verify'
                  )}
                </Button>
              </div>
            ) : (
              <Input 
                id={field.name}
                name={field.name}
                type={field.type}
                placeholder={field.placeholder}
                value={formData[field.name as keyof typeof formData]}
                onChange={handleChange}
                onFocus={handleFocus}
                onBlur={handleBlur}
                onKeyDown={handleKeyDown}
              />
            )}
            
            {/* Show tip for Telegram field only when focused */}
            {field.name === 'telegramId' && isTelegramFocused && (
              <p className="text-xs text-gray-500 mt-1">
                ðŸ’¡ Enter your Telegram ID exactly as it appears - it&apos;s case sensitive
              </p>
            )}
            
            {/* Show verification steps box for Telegram field when verification was attempted and failed */}
            {field.name === 'telegramId' && verificationAttempted && !isVerifying && !isVerified && (
              <div className="mt-3 p-3 bg-warning-light border border-warning-medium rounded-md">
                <h4 className="text-sm font-medium text-warning-medium mb-2">ðŸ“‹ Steps to Verify Your Telegram ID:</h4>
                <ol className="text-xs text-warning-medium space-y-1 list-decimal list-inside mb-3">
                  <li>Click on Start Bot Button</li>
                  <li>Send /start to the bot</li>
                  <li>Come back and Verify again</li>
                </ol>
                <Button asChild variant="outline" size="xs"
                  className="text-xs w-max border-warning-medium text-warning-medium hover:bg-warning-medium hover:text-white">
                  <a href={TELEGRAM_BOT_URL} target="_blank" rel="noopener noreferrer">Start Bot</a>
                </Button>
              </div>
            )}
          </div>
        ))}
      </div>  
    </div>
  )
}

export default ContactDetails



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\Form\Steps\CreativeDetails.tsx
================================================================================

"use client"

import { Constants } from '@/app/Constants/Constants'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { File, FileArchive, PencilLine, Search } from 'lucide-react'
import React, { useEffect, useState } from 'react'
import { FileUploadModal, UploadType, FromSubjectLinesModal, SingleCreativeView, MultipleCreativeView } from '@/components/modals'
import { formatFileSize } from '@/constants'

type UploadedFileMeta = {
  id: string;           
  name: string;
  url: string;          
  size: number;
  type: string;
  source?: 'single' | 'zip';
  html?: boolean;       
  previewUrl?: string;
  assetCount?: number;
  hasAssets?: boolean;
};

type UploadError = { scope: 'single' | 'zip'; message: string };

// API response types for better type safety
interface SingleUploadResponse {
  success: boolean;
  file?: {
    fileId: string;
    fileName: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    uploadDate: string;
  }
  zipAnalysis?: {
    isSingleCreative: boolean
    mainCreative: {
      fileId: string
      fileName: string
      fileUrl: string
      fileSize: number
      fileType: string
      previewUrl?: string
    }
    assetCount: number
    assetTypes: string[]
    totalSize: number
    structure: string
  }
}

interface ZipUploadResponse {
  extractedFiles: Array<{
    fileId: string;
    fileName: string;
    fileUrl: string;
    fileSize: number;
    fileType?: string;
    previewUrl?: string; // Backend populates this for image files
  }>;
}

interface CreativeDetailsProps {
  formData: {
    offerId: string;
    creativeType: string;
    additionalNotes: string;
    fromLines: string;
    subjectLines: string;
    priority: string;
  };
  onDataChange: (data: Partial<CreativeDetailsProps['formData']>) => void;
  onFilesChange?: (files: UploadedFileMeta[]) => void;
}

const CreativeDetails: React.FC<CreativeDetailsProps> = ({ formData, onDataChange, onFilesChange }) => {
  
  const [offerSearchTerm, setOfferSearchTerm] = useState('')
  const [offerOptions, setOfferOptions] = useState<Array<{label: string; value: string}>>([])
  const [isLoadingOffers, setIsLoadingOffers] = useState(true)
  
  useEffect(() => {
    let isMounted = true;
    (async () => {
      try {
        const res = await fetch('/api/everflow/offers', { cache: 'no-store' });
        if (!res.ok) throw new Error(await res.text());
        const offerIds = await res.json();
        if (!isMounted) return;
        const offers = offerIds.map((id: string) => ({ 
          label: `Offer ID: ${id}`, 
          value: id 
        }));
        setOfferOptions(offers);
        setIsLoadingOffers(false);
      } catch (e) {
        console.error('Failed to fetch offers:', e);
        if (!isMounted) return;
        setOfferOptions([]);
        setIsLoadingOffers(false);
      }
    })();
    return () => { isMounted = false; };
  }, []);
  
  const [isUploadModalOpen, setIsUploadModalOpen] = useState(false)
  const [currentUploadType, setCurrentUploadType] = useState<UploadType>('single')
  const [isFromSubjectLinesModalOpen, setIsFromSubjectLinesModalOpen] = useState(false)
  
  const [hasFromSubjectLines, setHasFromSubjectLines] = useState(false)
  const [hasUploadedFiles, setHasUploadedFiles] = useState(false)
  
  // Single Creative View Modal state
  const [isSingleCreativeViewOpen, setIsSingleCreativeViewOpen] = useState(false)
  const [selectedCreative, setSelectedCreative] = useState<UploadedFileMeta | null>(null)
  
  // Multiple Creative View Modal state
  const [isMultipleCreativeViewOpen, setIsMultipleCreativeViewOpen] = useState(false)
  const [selectedCreatives, setSelectedCreatives] = useState<UploadedFileMeta[]>([])
  const [zipFileName, setZipFileName] = useState<string>('')
  
  // Store ZIP filename for uploaded files summary (persists after modal close)
  const [uploadedZipFileName, setUploadedZipFileName] = useState<string>('')
  
  // File management state
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFileMeta[]>([])
  const [uploading, setUploading] = useState(false)
  const [progress, setProgress] = useState<number | null>(null)
  const [lastError, setLastError] = useState<UploadError | null>(null)
  
  useEffect(() => {
    onFilesChange?.(uploadedFiles);
    // Ensure hasUploadedFiles stays in sync with uploadedFiles array
    setHasUploadedFiles(uploadedFiles.length > 0);
  }, [uploadedFiles, onFilesChange]);

  // Cleanup function for timeouts
  useEffect(() => {
    return () => {
      // Cleanup any pending timeouts when component unmounts
      // This prevents memory leaks from setTimeout calls
    };
  }, []);

  const handleSelectChange = (fieldName: string, value: string) => {
    onDataChange({ [fieldName]: value })
    
    // Clear search term when offer is selected
    if (fieldName === 'offerId') {
      setOfferSearchTerm('')
    }
  }

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    onDataChange({ [name]: value })
  }
  
  // File management helpers
  const addFiles = (files: UploadedFileMeta[]) => {
    setUploadedFiles(prev => {
      const updated = [...prev, ...files]
      // Update hasUploadedFiles based on the new array length
      setHasUploadedFiles(updated.length > 0)
      return updated
    })
  }

  const removeFile = (id: string) => {
    setUploadedFiles(prev => {
      const updated = prev.filter(f => f.id !== id)
      // Update hasUploadedFiles based on the new array length
      setHasUploadedFiles(updated.length > 0)
      return updated
    })
  }

  const makeThumb = (file: File) =>
    new Promise<string | undefined>((resolve) => {
      if (!file.type.startsWith('image/')) return resolve(undefined)
      const reader = new FileReader()
      reader.onload = () => resolve(typeof reader.result === 'string' ? reader.result : undefined)
      reader.readAsDataURL(file)
    })

  const resetFeedback = () => { setLastError(null); setProgress(null) }

  // Open Single Creative View Modal
  const openSingleCreativeView = (creative: UploadedFileMeta) => {
    setSelectedCreative(creative)
    setIsSingleCreativeViewOpen(true)
  }

  // Open Multiple Creative View Modal
  const openMultipleCreativeView = (creatives: UploadedFileMeta[], fileName?: string) => {
    setSelectedCreatives(creatives)
    setZipFileName(fileName || '')
    setUploadedZipFileName(fileName || '') // Persist ZIP filename for summary
    setIsMultipleCreativeViewOpen(true)
  }

  // Handle removing a creative from the multiple view
  const handleRemoveCreative = (creativeId: string) => {
    // Remove from selectedCreatives
    setSelectedCreatives(prev => prev.filter(creative => creative.id !== creativeId))
    
    // Remove from uploadedFiles
    setUploadedFiles(prev => {
      const updated = prev.filter(file => file.id !== creativeId)
      setHasUploadedFiles(updated.length > 0)
      return updated
    })
  }

  const handleTextareaChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const { name, value } = e.target
    onDataChange({ [name]: value })
  }
  
    // File upload handlers
  const handleSingleFileUpload = async (file: File) => {
    resetFeedback();
    try {
      setUploading(true);
      setProgress(1);

      // send to your existing single upload endpoint
      const fd = new FormData();
      fd.append('file', file);
      
      // Smart ZIP handling: Check if it's a ZIP file
      if (file.type === 'application/zip' || file.name.toLowerCase().endsWith('.zip')) {
        // Add smart detection flag to determine single vs multiple creatives
        fd.append('smartDetection', 'true');
      }
      
      const r = await fetch('/api/upload', { method: 'POST', body: fd });
      if (!r.ok) throw new Error(await r.text());
      const data: SingleUploadResponse = await r.json();

      // Handle smart ZIP detection response
      if (data.zipAnalysis) {
        if (data.zipAnalysis.isSingleCreative) {
          // Treat as single creative with assets
          const mainFile = data.zipAnalysis.mainCreative;
          const uploadedFile: UploadedFileMeta = {
            id: mainFile.fileId,
            name: mainFile.fileName,
            url: mainFile.fileUrl,
            size: mainFile.fileSize,
            type: /\.html?$/i.test(mainFile.fileName)
              ? 'html'
              : /\.(png|jpe?g|gif|webp)$/i.test(mainFile.fileName)
              ? 'image'
              : 'other',
            source: 'single' as const,
            html: /\.html?$/i.test(mainFile.fileName),
            previewUrl: mainFile.previewUrl,
            assetCount: data.zipAnalysis.assetCount,
            hasAssets: data.zipAnalysis.assetCount > 0
          };

          addFiles([uploadedFile]);
          setProgress(100);
          openSingleCreativeView(uploadedFile);
          return;
        } else {
          // Redirect to multiple creatives flow
          console.log('ZIP contains multiple creatives, redirecting to multiple upload flow');
          await handleMultipleFileUpload(file);
          return;
        }
      }

      // Regular single file upload (non-ZIP)
      const uploaded = data.file;
      if (!uploaded) {
        throw new Error('Upload response missing file data');
      }
      
      const previewUrl = await makeThumb(file);

      const uploadedFile: UploadedFileMeta = {
        id: uploaded.fileId,
        name: uploaded.fileName,
        url: uploaded.fileUrl,
        size: uploaded.fileSize,
        type: /\.html?$/i.test(uploaded.fileName)
          ? 'html'
          : /\.(png|jpe?g|gif|webp)$/i.test(uploaded.fileName)
          ? 'image'
          : 'other',
        source: 'single' as const,
        html: /\.html?$/i.test(uploaded.fileName),
        previewUrl: previewUrl || (/\.(png|jpe?g|gif|webp)$/i.test(uploaded.fileName) ? uploaded.fileUrl : undefined)
      };

      addFiles([uploadedFile]);
      setProgress(100);
      
      // Open SingleCreativeView immediately (modal will close after this completes)
      openSingleCreativeView(uploadedFile);
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : 'Upload failed';
      setLastError({ scope: 'single', message: errorMessage });
      throw e; // Re-throw to prevent modal from closing on error
    } finally {
      setUploading(false);
      setTimeout(() => setProgress(null), 600);
    }
  }
  
  const handleMultipleFileUpload = async (file: File) => {
    resetFeedback();
    try {
      setUploading(true);
      setProgress(1);

      const fd = new FormData();
      fd.append('file', file);
      const r = await fetch('/api/upload-zip', { method: 'POST', body: fd });
      if (!r.ok) throw new Error(await r.text());
      const data: ZipUploadResponse = await r.json();

      const mapped: UploadedFileMeta[] = (data.extractedFiles || []).map((f) => {
        const isImageFile = /\.(png|jpe?g|gif|webp|svg)$/i.test(f.fileName);
        return {
          id: f.fileId,
          name: f.fileName,
          url: f.fileUrl,
          size: f.fileSize,
          type: /\.html?$/i.test(f.fileName)
            ? 'html'
            : /\.(png|jpe?g|gif|webp|svg)$/i.test(f.fileName)
            ? 'image'
            : 'other',
          source: 'zip' as const,
          html: /\.html?$/i.test(f.fileName),
          // Backend implements thumbnail generation, f.previewUrl contains the thumbnail URL
          previewUrl: f.previewUrl || (isImageFile ? f.fileUrl : undefined),
        };
      });

      addFiles(mapped);
      setProgress(100);
      
      // Open MultipleCreativeView with all files (modal will close after this completes)
      if (mapped.length > 0) {
        openMultipleCreativeView(mapped, file.name);
      }
    } catch (e: unknown) {
      const errorMessage = e instanceof Error ? e.message : 'ZIP extraction failed';
      setLastError({ scope: 'zip', message: errorMessage });
      throw e; // Re-throw to prevent modal from closing on error
    } finally {
      setUploading(false);
      setTimeout(() => setProgress(null), 600);
    }
  }
  
     const handleFromSubjectLinesSave = (fromLines: string, subjectLines: string) => {
     // Store from and subject lines in form data
     onDataChange({ fromLines, subjectLines })
     
     // Set flag to show uploaded lines instead of upload buttons
     setHasFromSubjectLines(true)
   }
  
  // Handle viewing from/subject lines
  const handleViewFromSubjectLines = () => {
    setIsFromSubjectLinesModalOpen(true)
  }
  
  // Handle deleting from/subject lines
  const handleDeleteFromSubjectLines = () => {
    onDataChange({ fromLines: '', subjectLines: '' })
    setHasFromSubjectLines(false)
  }

  // Handle viewing uploaded files
  const handleViewUploadedFiles = () => {
    if (uploadedFiles.length === 1) {
      // Single file - open SingleCreativeView
      openSingleCreativeView(uploadedFiles[0])
    } else if (uploadedFiles.length > 1) {
      // Multiple files - open MultipleCreativeView
      openMultipleCreativeView(uploadedFiles)
    }
  }

  // Handle filename changes from SingleCreativeView
  const handleFileNameChange = (fileId: string, newFileName: string) => {
    setUploadedFiles(prev => prev.map(file => 
      file.id === fileId ? { ...file, name: newFileName } : file
    ))
  }

  // Handle deleting all uploaded files
  const handleDeleteUploadedFiles = () => {
    setUploadedFiles([])
    setHasUploadedFiles(false)
    setUploadedZipFileName('') // Clear ZIP filename when files are deleted
    // Reset any upload-related state to ensure clean slate
    setLastError(null)
    setProgress(null)
    // Close upload modal if it's open to reset its state
    setIsUploadModalOpen(false)
  }
  
  // Handle priority change
  const handlePriorityChange = (priority: string) => {
    onDataChange({ priority })
  }
  
  // Separate fields by type for proper ordering
  const selectFields = Constants.formFields.filter(field => 
    ['offerId', 'creativeType'].includes(field.name)
  )
  
  const textareaFields = Constants.formFields.filter(field => 
    ['additionalNotes'].includes(field.name)
  )

  const renderField = (field: {
    name: string;
    type: string;
    placeholder: string;
    label?: string;
    options?: Array<{ label: string; value: string }>;
  }) => {
    if (field.type === 'select') {
      // Special handling for offer dropdown with search
      if (field.name === 'offerId') {
        const filteredOptions = offerOptions.filter(option =>
          option.label.toLowerCase().includes(offerSearchTerm.toLowerCase())
        )
        
        return (
          <Select 
            value={formData[field.name as keyof typeof formData]} 
            onValueChange={(value) => handleSelectChange(field.name, value)}
            onOpenChange={(open) => {
              if (open) {
                setOfferSearchTerm('')
              }
            }}
          >
            <SelectTrigger className="w-full h-12">
              <SelectValue placeholder={field.placeholder} />
            </SelectTrigger>
            <SelectContent>
              {/* Search Input */}
              <div className="p-3 border-b border-color-border">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-color-muted-foreground w-4 h-4" />
                  <Input
                    placeholder="Search offers..."
                    value={offerSearchTerm}
                    onChange={(e) => setOfferSearchTerm(e.target.value)}
                    className="pl-10 h-9 text-sm border-0 focus-visible:ring-0 focus-visible:border-0 shadow-none"
                  />
                </div>
              </div>
              
              {/* Filtered Options */}
              {filteredOptions.length > 0 ? (
                filteredOptions.map((option) => (
                  <SelectItem key={option.value} value={option.value}>
                    {option.label}
                  </SelectItem>
                ))
              ) : (
                <div className="px-3 py-2 text-sm text-color-muted-foreground text-center">
                  {offerSearchTerm ? 'No offers found' : (isLoadingOffers ? 'Loading offers...' : 'No offers available')}
                </div>
              )}
            </SelectContent>
          </Select>
        )
      }
      
      // Regular select for other fields
      return (
        <Select value={formData[field.name as keyof typeof formData]} onValueChange={(value) => handleSelectChange(field.name, value)}>
          <SelectTrigger className="w-full h-12">
            <SelectValue placeholder={field.placeholder || 'Select an option'} />
          </SelectTrigger>
          <SelectContent>
            {field.options && field.options.length > 0 ? (
              field.options.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))
            ) : (
              <div className="px-3 py-2 text-sm text-color-muted-foreground text-center">
                No options available
              </div>
            )}
          </SelectContent>
        </Select>
      )
    } else if (field.type === 'button') {
      return (
        <Button 
          variant="outline" 
          className="w-full h-10 px-3 py-2 border border-color-border rounded-md focus:outline-none focus:ring-2 focus:ring-color-ring focus:border-transparent"
          type="button"
        >
          {field.placeholder}
        </Button>
      )
    }
    
    else if (field.type === 'textarea') {
      return (
        <Textarea
          id={field.name}
          name={field.name}
          value={formData[field.name as keyof typeof formData]}
          onChange={handleTextareaChange}
          placeholder={field.placeholder}
          rows={4}
          className="w-full h-24 px-3 py-2 border border-color-border rounded-md focus:outline-none focus:ring-2 focus:ring-color-ring focus:border-transparent resize-none bg-white"
        />
      )
    } else {
      return (
        <input
          type={field.type}
          id={field.name}
          name={field.name}
          value={formData[field.name as keyof typeof formData]}
          onChange={handleInputChange}
          placeholder={field.placeholder}
          className="w-full h-10 px-3 py-2 border border-color-border rounded-md focus:outline-none focus:ring-2 focus:ring-color-ring focus:border-transparent"
        />
      )
    }
  }

  return (
    <div className="space-y-6">
      {/* Select Fields (Offer ID & Creative Type) */}
      <div className="space-y-4">
        {selectFields.filter(field => field && field.name).map((field) => (
          <div key={field.name} className="space-y-2">
            <Label htmlFor={field.name}>{field.label}</Label>
            {renderField(field)}
          </div>
        ))}
      </div>
      
      {/* Upload Creative Buttons or Uploaded Content */}
      <div className="space-y-4">
        <Label className="text-base font-medium">
          {hasFromSubjectLines ? 'Uploaded From & Subject Lines' : hasUploadedFiles ? 'Uploaded Files' : 'Upload Creatives'}
        </Label>
        
        {hasFromSubjectLines ? (
          // Show uploaded from/subject lines with view/delete buttons
          <div className="p-4 border border-green-200 bg-green-50 rounded-lg">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <PencilLine className="h-5 w-5 text-green-600" />
                <div>
                  <p className="font-medium text-green-800">From & Subject Lines Uploaded</p>
                  <p className="text-sm text-green-600">
                    {formData.fromLines.split('\n').length} from lines â€¢ {formData.subjectLines.split('\n').length} subject lines
                  </p>
                </div>
              </div>
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleViewFromSubjectLines}
                  className="text-green-700 border-green-300 hover:bg-green-100"
                >
                  View
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleDeleteFromSubjectLines}
                  className="text-red-700 border-red-300 hover:bg-red-100"
                >
                  Delete
                </Button>
              </div>
            </div>
          </div>
        ) : hasUploadedFiles ? (
          // Show uploaded files summary with view/delete buttons
          <div className="p-4 border border-green-200 bg-green-50 rounded-lg">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                {uploadedZipFileName ? (
                  <FileArchive className="h-5 w-5 text-green-600" />
                ) : (
                  <File className="h-5 w-5 text-green-600" />
                )}
                <div>
                  <p className="font-medium text-green-800">
                    {uploadedFiles.length === 1 
                      ? uploadedFiles[0].name 
                      : (uploadedZipFileName || `${uploadedFiles.length} Files Uploaded`)
                    }
                  </p>
                  <p className="text-sm text-green-600">
                    {uploadedFiles.length} file{uploadedFiles.length !== 1 ? 's' : ''} â€¢ {uploadedFiles.reduce((total, file) => total + file.size, 0) > 0 ? formatFileSize(uploadedFiles.reduce((total, file) => total + file.size, 0)) : '0 B'}
                  </p>
                </div>
              </div>
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleViewUploadedFiles}
                  className="text-green-700 border-green-300 hover:bg-green-100"
                >
                  View
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleDeleteUploadedFiles}
                  className="text-red-700 border-red-300 hover:bg-red-100"
                >
                  Delete
                </Button>
              </div>
            </div>
          </div>
        ) : (
          // Show upload buttons
          <div className={`grid gap-4 ${formData.creativeType === 'email' ? 'grid-cols-1 md:grid-cols-3' : 'grid-cols-1 md:grid-cols-2'}`}>
            {/* Single Creative - Always visible */}
            <Button
              variant="outline"
              className="h-20 flex flex-col items-center justify-center gap-2 p-4 border-2 border-dashed border-color-border hover:border-blue-400 hover:bg-blue-50 transition-all duration-200"
              onClick={() => {
                // Reset any previous upload state
                setLastError(null)
                setProgress(null)
                setCurrentUploadType('single')
                setIsUploadModalOpen(true)
              }}
            >
              <File className="text-blue-400" style={{ width: '20px', height: '20px' }} />
              <span className="text-sm font-medium text-center">Single Creative</span>
            </Button>

            {/* Multiple Creatives - Always visible */}
            <Button
              variant="outline"
              className="h-20 flex flex-col items-center justify-center gap-2 p-4 border-2 border-dashed border-color-border hover:border-blue-400 hover:bg-blue-50 transition-all duration-200"
              onClick={() => {
                // Reset any previous upload state
                setLastError(null)
                setProgress(null)
                setCurrentUploadType('multiple')
                setIsUploadModalOpen(true)
              }}
            >
              <FileArchive className="text-blue-400" style={{ width: '20px', height: '20px' }} />
              <span className="text-sm font-medium text-center">Multiple Creatives</span>
            </Button>

            {/* From & Subject Lines - Only visible when Email is selected */}
            {formData.creativeType === 'email' && (
              <Button
                variant="outline"
                className="h-20 flex flex-col items-center justify-center gap-2 p-4 border-2 border-dashed border-color-border hover:border-blue-400 hover:bg-blue-50 transition-all duration-200"
                onClick={() => setIsFromSubjectLinesModalOpen(true)}
              >
                <PencilLine className="text-blue-400" style={{ width: '20px', height: '20px' }} />
                <span className="text-sm font-medium text-center">From & Subject Lines</span>
              </Button>
            )}
                     </div>
         )}
       </div>
       
       {/* Uploaded files preview/list - Only show when not in summary mode */}
       {uploadedFiles.length > 0 && !hasUploadedFiles && (
         <div className="mt-4">
           <div className="flex items-center justify-between mb-2">
             <h4 className="text-sm font-semibold text-gray-800">
               Uploaded Files ({uploadedFiles.length})
             </h4>
           </div>

           <div className="grid gap-3 sm:grid-cols-2">
             {uploadedFiles.map(f => (
               <div 
                 key={f.id} 
                 className="flex items-center gap-3 p-3 rounded border bg-white hover:shadow-md transition-shadow cursor-pointer"
                 onClick={() => openSingleCreativeView(f)}
               >
                 {/* thumbnail */}
                 <div className="w-14 h-14 flex items-center justify-center bg-gray-100 rounded overflow-hidden">
                   {f.previewUrl ? (
                     <img src={f.previewUrl} alt={f.name} className="object-cover w-full h-full" />
                   ) : f.html ? (
                     <span className="text-xs text-gray-600">HTML</span>
                   ) : (
                     <span className="text-xs text-gray-600">FILE</span>
                   )}
                 </div>

                 {/* meta */}
                 <div className="min-w-0 flex-1">
                   <p className="text-sm font-medium truncate">{f.name}</p>
                   <p className="text-xs text-gray-500 truncate">{f.type} Â· {formatFileSize(f.size)}</p>
                   <div className="flex gap-2 mt-1">
                     <button
                       onClick={(e) => {
                         e.stopPropagation();
                         openSingleCreativeView(f);
                       }}
                       className="text-xs px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                     >
                       View
                     </button>
                     <a 
                       href={f.url} 
                       target="_blank" 
                       onClick={(e) => e.stopPropagation()}
                       className="text-xs px-2 py-1 border border-gray-300 rounded hover:bg-gray-50 transition-colors"
                     >
                       Open
                     </a>
                   </div>
                 </div>

                 {/* remove */}
                 <button
                   className="text-xs px-2 py-1 border rounded hover:bg-gray-50"
                   onClick={(e) => {
                     e.stopPropagation();
                     removeFile(f.id);
                   }}
                 >
                   Remove
                 </button>
               </div>
             ))}
           </div>
         </div>
       )}
       
       {/* Priority Toggle */}
      <div className="space-y-3">
        <Label className="text-base font-medium text-gray-700">Set Priority</Label>
        <div className="flex bg-white border border-gray-300 rounded-lg p-1 w-fit shadow-sm">
          {Constants.priorityLevels.map((priority) => (
            <button
              key={priority.value}
              onClick={() => handlePriorityChange(priority.value)}
              className={`px-6 py-2.5 rounded-md text-sm font-semibold transition-all duration-200 ${
                formData.priority === priority.value
                  ? 'bg-blue-400 text-white shadow-sm border border-blue-400'
                  : 'text-gray-600 hover:text-gray-800 hover:bg-gray-50'
              }`}
            >
              {priority.name}
            </button>
          ))}
        </div>
      </div>
      
      {/* Textarea Fields (Additional Notes) */}
      <div className="space-y-4">
        {textareaFields.filter(field => field && field.name).map((field) => (
          <div key={field.name} className="space-y-2">
            <Label htmlFor={field.name}>{field.label}</Label>
            {renderField(field)}
          </div>
        ))}
      </div>
      
      {/* Unified File Upload Modal */}
      <FileUploadModal
        isOpen={isUploadModalOpen}
        onClose={() => setIsUploadModalOpen(false)}
        uploadType={currentUploadType}
        onFileUpload={currentUploadType === 'single' ? handleSingleFileUpload : handleMultipleFileUpload}
      />
      
      {/* From & Subject Lines Modal */}
      <FromSubjectLinesModal
        isOpen={isFromSubjectLinesModalOpen}
        onClose={() => setIsFromSubjectLinesModalOpen(false)}
        onSave={handleFromSubjectLinesSave}
        initialFromLines={formData.fromLines}
        initialSubjectLines={formData.subjectLines}
      />
      
      {/* Single Creative View Modal */}
      {selectedCreative && (
        <SingleCreativeView
          isOpen={isSingleCreativeViewOpen}
          onClose={() => {
            setIsSingleCreativeViewOpen(false)
            setSelectedCreative(null)
          }}
          creative={selectedCreative}
          onFileNameChange={handleFileNameChange}
        />
      )}
      
      {/* Multiple Creative View Modal */}
      {selectedCreatives.length > 0 && (
        <MultipleCreativeView
          isOpen={isMultipleCreativeViewOpen}
          onClose={() => {
            setIsMultipleCreativeViewOpen(false)
            setSelectedCreatives([])
            setZipFileName('')
          }}
          creatives={selectedCreatives}
          zipFileName={zipFileName}
          onRemoveCreative={handleRemoveCreative}
          onFileNameChange={handleFileNameChange}
        />
      )}
    </div>
  )
}

export default CreativeDetails



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\Form\Steps\PersonalDetails.tsx
================================================================================

"use client"

import React from 'react'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Constants } from '@/app/Constants/Constants'

interface PersonalDetailsProps {
  formData: {
    affiliateId: string;
    companyName: string;
    firstName: string;
    lastName: string;
  };
  onDataChange: (data: Partial<PersonalDetailsProps['formData']>) => void;
}

const PersonalDetails: React.FC<PersonalDetailsProps> = ({ formData, onDataChange }) => {

  // Filter only the personal detail fields from Constants
  const personalFields = Constants.formFields.filter(field => 
    ['affiliateId', 'companyName', 'firstName', 'lastName'].includes(field.name)
  )

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    onDataChange({ [name]: value })
  }

  return (
    <div className="space-y-6">
      
      {/* Affiliate ID and Company Name - Single Column */}
      <div className="space-y-4">
        {personalFields.slice(0, 2).map((field) => (
          <div key={field.name} className="space-y-2">
            <Label htmlFor={field.name}>{field.label}</Label>
            <Input
              id={field.name}
              name={field.name}
              type={field.type}
              placeholder={field.placeholder}
              value={formData[field.name as keyof typeof formData]}
              onChange={handleChange}
            />
          </div>
        ))}
      </div>

      {/* First Name and Last Name - Responsive Layout */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {personalFields.slice(2, 4).map((field) => (
          <div key={field.name} className="space-y-2">
            <Label htmlFor={field.name}>{field.label}</Label>
            <Input
              id={field.name}
              name={field.name}
              type={field.type}
              placeholder={field.placeholder}
              value={formData[field.name as keyof typeof formData]}
              onChange={handleChange}
            />
          </div>
        ))}
      </div>
    </div>
  )
}

export default PersonalDetails



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\layout.tsx
================================================================================

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({
  variable: "--font-inter",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Creative Submission Form - Big Drops Marketing Group",
  description: "Submit your creatives for approval with Big Drops Marketing Group",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${inter.variable} antialiased`}
        style={{
          
        }}
      >
        {children}
      </body>
    </html>
  );
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\app\page.tsx
================================================================================

import CreativeForm from "@/app/Form/CreativeForm";

export default function Home() {
  return (
   <main>
    <CreativeForm />
   </main>
  );
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\modals\FileUploadModal.tsx
================================================================================

"use client";

import React from "react";
import { Button } from "@/components/ui/button";
import {
  X,
  Upload,
  CheckCircle,
  AlertCircle,
  FolderOpen,
  FileText,
  Image,
} from "lucide-react";
import { useFileUpload } from "@/hooks";
import { FILE_UPLOAD_CONFIG, formatFileSize } from "@/constants";
import { UploadAnalysis, AnalyzedItem } from "@/types/upload";

export type UploadType = "single" | "multiple";

type UploadProvider = "local" | "vercel-blob" | "s3";
type ChunkingConfig = { enabled: boolean; chunkSize: number }; // bytes

interface FileUploadModalProps {
  isOpen: boolean;
  onClose: () => void;
  uploadType: UploadType;
  onFileUpload: (file: File) => void;
  onZipAnalyzed?: (analysis: UploadAnalysis, file: File) => void;

  uploadEndpoint?: string;
  uploadZipEndpoint?: string;
  authHeaders?: Record<string, string>;
  userContext?: { userId?: string; role?: string };

  onUploadProgress?: (pct: number) => void;
  onUploadError?: (error: Error) => void;

  onServerValidate?: (file: File) => Promise<{ ok: boolean; reason?: string }>;

  retry?: { retries: number; baseDelayMs: number };
  chunking?: ChunkingConfig;
  provider?: UploadProvider;
  compressImages?: boolean;
  metadata?: Record<string, string | number | boolean>;
  enableVirusScan?: boolean;
  onPreviewGenerated?: (url: string) => void;
}

const FileUploadModal: React.FC<FileUploadModalProps> = ({
  isOpen,
  onClose,
  uploadType,
  onFileUpload,
  onZipAnalyzed,
}) => {
  const config =
    uploadType === "single"
      ? FILE_UPLOAD_CONFIG.SINGLE_CREATIVE
      : FILE_UPLOAD_CONFIG.MULTIPLE_CREATIVES;

  const [zipAnalysis, setZipAnalysis] = React.useState<UploadAnalysis | null>(
    null
  );
  const [isAnalyzing, setIsAnalyzing] = React.useState(false);

  const { state, handlers, startUpload } = useFileUpload(
    config.ALLOWED_TYPES,
    config.MAX_SIZE_MB,
    async (file: File) => {
      if (file.name.toLowerCase().endsWith(".zip") && onZipAnalyzed) {
        setIsAnalyzing(true);
        try {
          const analysis = await analyzeZipFile(file);
          setZipAnalysis(analysis);
          onZipAnalyzed(analysis, file);
          return;
        } catch (error) {
          console.error("ZIP analysis failed:", error);
        } finally {
          setIsAnalyzing(false);
        }
      }

      await onFileUpload(file);
      handlers.resetState();
      onClose();
    }
  );

  const analyzeZipFile = async (file: File): Promise<UploadAnalysis> => {
    const formData = new FormData();
    formData.append("file", file);

    const response = await fetch("/api/analyze-zip", {
      method: "POST",
      body: formData,
    });

    if (!response.ok) {
      throw new Error("ZIP analysis failed");
    }

    return response.json();
  };

  React.useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "unset";
    }

    return () => {
      document.body.style.overflow = "unset";
    };
  }, [isOpen]);

  React.useEffect(() => {
    if (isOpen) {
      const timer = setTimeout(() => {
        handlers.resetState();
      }, 0);
      return () => clearTimeout(timer);
    }
  }, [isOpen, handlers]);

  const handleClose = () => {
    handlers.resetState();
    onClose();
  };

  const getModalTitle = () => {
    return uploadType === "single"
      ? "Upload Single Creative"
      : "Upload Multiple Creatives";
  };

  const getDragDropContent = () => {
    if (state.uploadStatus === "success") {
      return (
        <div className="space-y-3">
          <CheckCircle className="h-12 w-12 text-green-500 mx-auto" />
          <div>
            <p className="text-sm font-medium text-green-900">
              Upload Successful!
            </p>
            <p className="text-xs text-green-600">File uploaded successfully</p>
          </div>
        </div>
      );
    }

    if (state.selectedFile) {
      return (
        <div className="space-y-3">
          <CheckCircle className="h-12 w-12 text-blue-500 mx-auto" />
          <div>
            <p className="text-sm font-medium text-gray-900">
              {state.selectedFile.name}
            </p>
            <p className="text-xs text-gray-500">
              {formatFileSize(state.selectedFile.size)}
            </p>
            {uploadType === "multiple" && (
              <p className="text-xs text-blue-600 font-medium">
                ZIP file ready for upload
              </p>
            )}
          </div>
        </div>
      );
    }

    return (
      <div className="space-y-3">
        <Upload className={`h-12 w-12 text-gray-400 mx-auto`} />
        <div>
          <p className="text-sm font-medium text-gray-900">
            {config.PLACEHOLDER}
          </p>
          <p className="text-xs text-gray-500">or click to browse</p>
        </div>
      </div>
    );
  };

  const getInfoBox = () => {
    if (uploadType === "multiple") {
      return (
        <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
          <div className="flex items-start gap-2">
            <FolderOpen className="h-4 w-4 text-blue-500 mt-0.5" />
            <div className="text-sm text-blue-700">
              <p className="font-medium">ZIP File Requirements:</p>
              <ul className="mt-1 space-y-1 text-xs">
                {config.REQUIREMENTS?.map((req: string, index: number) => (
                  <li key={index}>â€¢ {req}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      );
    }
    return null;
  };

  const getFileInfo = () => {
    if (!state.selectedFile) return null;

    return (
      <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md">
        <div className="flex items-center gap-2">
          <Upload className="h-4 w-4 text-gray-400" />
          <div className="flex-1 min-w-0">
            <p className="text-sm font-medium text-blue-900 truncate">
              {state.selectedFile.name}
            </p>
            <p className="text-xs text-blue-700">
              {formatFileSize(state.selectedFile.size)}
            </p>
          </div>
        </div>
      </div>
    );
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-color-border">
          <h2 className="text-xl font-semibold text-gray-900">
            {getModalTitle()}
          </h2>
          <Button
            variant="ghost"
            size="sm"
            onClick={handleClose}
            className="h-8 w-8 p-0 hover:bg-red-500"
          >
            <X className="h-4 w-4" />
          </Button>
        </div>

        {/* Content */}
        <div className="p-6">
          {/* Info Box - Only for multiple files */}
          {getInfoBox()}

          {/* Drag & Drop Area */}
          <div
            className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
              state.uploadStatus === "success"
                ? "border-green-400 bg-green-50"
                : state.dragActive
                ? "border-blue-400 bg-blue-50"
                : state.selectedFile
                ? "border-blue-400 bg-blue-50"
                : "border-gray-300 bg-gray-50"
            }`}
            onDragEnter={handlers.handleDrag}
            onDragLeave={handlers.handleDrag}
            onDragOver={handlers.handleDrag}
            onDrop={handlers.handleDrop}
          >
            {getDragDropContent()}
          </div>

          {/* Analyzing ZIP state */}
          {isAnalyzing && (
            <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md flex items-center justify-center gap-2 text-blue-700">
              <div className="animate-spin rounded-full h-4 w-4 border-2 border-blue-200 border-t-blue-600"></div>
              <span className="text-sm">Analyzing ZIP file...</span>
            </div>
          )}

          {/* ZIP Analysis Results */}
          {zipAnalysis && (
            <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded-md">
              <div className="flex items-center gap-2 mb-3">
                <CheckCircle className="h-5 w-5 text-green-600" />
                <h3 className="text-sm font-medium text-green-900">
                  ZIP Analysis Complete
                </h3>
              </div>

              <div className="space-y-2 text-sm text-green-800">
                <p>
                  <strong>Mode:</strong>{" "}
                  {zipAnalysis.isSingleCreative
                    ? "Single Creative"
                    : "Multiple Creatives"}
                </p>
                <p>
                  <strong>Files:</strong> {zipAnalysis.counts.total} total
                </p>
                <p>
                  <strong>HTML:</strong> {zipAnalysis.counts.htmls}
                </p>
                <p>
                  <strong>Images:</strong> {zipAnalysis.counts.images}
                </p>
                <p>
                  <strong>Others:</strong> {zipAnalysis.counts.others}
                </p>
              </div>

              {/* Preview of analyzed items */}
              <div className="mt-3 space-y-2">
                {zipAnalysis.items.slice(0, 5).map((item) => (
                  <div
                    key={item.id}
                    className="flex items-center gap-2 p-2 bg-white rounded border"
                  >
                    {item.type === "html" ? (
                      <FileText className="h-4 w-4 text-blue-500" />
                    ) : item.type === "image" ? (
                      <Image className="h-4 w-4 text-green-500" />
                    ) : (
                      <div className="h-4 w-4 bg-gray-300 rounded" />
                    )}
                    <span className="text-xs text-gray-700 truncate flex-1">
                      {item.name}
                    </span>
                    <span className="text-xs text-gray-500">
                      {formatFileSize(item.size)}
                    </span>
                  </div>
                ))}
                {zipAnalysis.items.length > 5 && (
                  <p className="text-xs text-gray-500 text-center">
                    +{zipAnalysis.items.length - 5} more files
                  </p>
                )}
              </div>
            </div>
          )}

          {/* Uploading state */}
          {state.uploadStatus === "uploading" && (
            <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-md flex items-center justify-center gap-2 text-blue-700">
              <div className="animate-spin rounded-full h-4 w-4 border-2 border-blue-200 border-t-blue-600"></div>
              <span className="text-sm">Uploadingâ€¦</span>
            </div>
          )}

          {/* File Input */}
          <input
            type="file"
            id="file-upload"
            className="hidden"
            onChange={handlers.handleFileInput}
            accept={config.ACCEPT_EXTENSIONS}
          />

          {/* Browse Button - Only show when no file is selected */}
          {!state.selectedFile && (
            <div className="mt-4 text-center">
              <Button
                variant="outline"
                onClick={() => document.getElementById("file-upload")?.click()}
                className="w-full"
              >
                Browse {uploadType === "single" ? "Files" : "ZIP Files"}
              </Button>
            </div>
          )}

          {/* Upload button removed: upload auto-starts on selection */}

          {/* Error Message */}
          {state.errorMessage && (
            <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-md flex items-center gap-2">
              <AlertCircle className="h-4 w-4 text-red-500" />
              <p className="text-sm text-red-700">{state.errorMessage}</p>
            </div>
          )}

          {/* File Info */}
          {getFileInfo()}

          {/* Close button when ZIP analysis is complete */}
          {zipAnalysis && (
            <div className="mt-4 text-center">
              <Button
                onClick={handleClose}
                className="w-full bg-green-600 hover:bg-green-700"
              >
                Close
              </Button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default FileUploadModal;



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\modals\FromSubjectLinesModal.tsx
================================================================================

"use client"

import React, { useState, useEffect } from 'react'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { X, PencilLine, Info } from 'lucide-react'
import { Constants } from '@/app/Constants/Constants'

interface FromSubjectLinesModalProps {
  isOpen: boolean
  onClose: () => void
  onSave: (fromLines: string, subjectLines: string) => void
  initialFromLines?: string
  initialSubjectLines?: string
}

const FromSubjectLinesModal: React.FC<FromSubjectLinesModalProps> = ({
  isOpen,
  onClose,
  onSave,
  initialFromLines = '',
  initialSubjectLines = ''
}) => {
  const [fromLines, setFromLines] = useState(initialFromLines)
  const [subjectLines, setSubjectLines] = useState(initialSubjectLines)
  const [errors, setErrors] = useState<{ fromLines?: string; subjectLines?: string }>({})

  // Prevent background scrolling when modal is open
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden'
    } else {
      document.body.style.overflow = 'unset'
    }

    // Cleanup function to restore scrolling when component unmounts
    return () => {
      document.body.style.overflow = 'unset'
    }
  }, [isOpen])

  // Update state when modal opens with initial values
  useEffect(() => {
    if (isOpen) {
      setFromLines(initialFromLines)
      setSubjectLines(initialSubjectLines)
      setErrors({})
    }
  }, [isOpen, initialFromLines, initialSubjectLines])

  const handleSave = () => {
    // Reset errors
    setErrors({})
    
    // Validate inputs
    const newErrors: { fromLines?: string; subjectLines?: string } = {}
    
    if (!fromLines.trim()) {
      newErrors.fromLines = 'From lines are required'
    }
    
    if (!subjectLines.trim()) {
      newErrors.subjectLines = 'Subject lines are required'
    }
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors)
      return
    }
    
    // Save and close
    onSave(fromLines.trim(), subjectLines.trim())
    handleClose()
  }

  const handleClose = () => {
    setFromLines('')
    setSubjectLines('')
    setErrors({})
    onClose()
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-2xl">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-color-border">
          <div className="flex items-center gap-3">
            <PencilLine className="h-6 w-6 text-blue-500" />
            <h2 className="text-xl font-semibold text-gray-900">{Constants.fromSubjectLinesConfig.title}</h2>
          </div>
          <Button
            variant="ghost"
            size="sm"
            onClick={handleClose}
            className="h-8 w-8 p-0 hover:bg-red-500 hover:text-white transition-colors"
          >
            <X className="h-4 w-4" />
          </Button>
        </div>

        {/* Content */}
        <div className="p-6 space-y-6">
          {/* Info Box */}
          <div className="p-4 bg-blue-50 border border-blue-200 rounded-md">
            <div className="flex items-start gap-2">
              <Info className="h-4 w-4 text-blue-500 mt-0.5" />
              <div className="text-sm text-blue-700">
                <p className="font-medium">{Constants.fromSubjectLinesConfig.guidelines.title}</p>
                <ul className="mt-2 space-y-1 text-xs">
                  {Constants.fromSubjectLinesConfig.guidelines.items.map((item, index) => (
                    <li key={index}>â€¢ {item}</li>
                  ))}
                </ul>
              </div>
            </div>
          </div>

          {/* From Lines */}
          <div className="space-y-3">
            <Label htmlFor="fromLines" className="text-base font-medium">
              {Constants.fromSubjectLinesConfig.fromLines.label}
            </Label>
            <Textarea
              id="fromLines"
              placeholder={Constants.fromSubjectLinesConfig.fromLines.placeholder}
              value={fromLines}
              onChange={(e) => setFromLines(e.target.value)}
              rows={4}
              className={`w-full resize-none ${errors.fromLines ? 'border-red-500 focus-visible:border-red-500 focus-visible:ring-red-500/50' : ''}`}
            />
            {errors.fromLines && (
              <p className="text-sm text-red-600">{errors.fromLines}</p>
            )}
            <p className="text-xs text-gray-500">
              {Constants.fromSubjectLinesConfig.fromLines.helpText}
            </p>
          </div>

          {/* Subject Lines */}
          <div className="space-y-3">
            <Label htmlFor="subjectLines" className="text-base font-medium">
              {Constants.fromSubjectLinesConfig.subjectLines.label}
            </Label>
            <Textarea
              id="subjectLines"
              placeholder={Constants.fromSubjectLinesConfig.subjectLines.placeholder}
              value={subjectLines}
              onChange={(e) => setSubjectLines(e.target.value)}
              rows={4}
              className={`w-full resize-none ${errors.subjectLines ? 'border-red-500 focus-visible:border-red-500 focus-visible:ring-red-500/50' : ''}`}
            />
            {errors.subjectLines && (
              <p className="text-sm text-red-600">{errors.subjectLines}</p>
            )}
            <p className="text-xs text-gray-500">
              {Constants.fromSubjectLinesConfig.subjectLines.helpText}
            </p>
          </div>

          {/* Character Count */}
          <div className="flex justify-between text-xs text-gray-500">
            <span>{Constants.fromSubjectLinesConfig.characterCount.fromLines.replace('{count}', fromLines.length.toString())}</span>
            <span>{Constants.fromSubjectLinesConfig.characterCount.subjectLines.replace('{count}', subjectLines.length.toString())}</span>
          </div>
        </div>

        {/* Footer */}
        <div className="flex gap-3 p-6 border-t border-color-border">
          <Button
            variant="outline"
            onClick={handleClose}
            className="flex-1"
          >
            {Constants.fromSubjectLinesConfig.buttons.cancel}
          </Button>
          <Button
            onClick={handleSave}
            className="flex-1"
            disabled={!fromLines.trim() || !subjectLines.trim()}
          >
            {Constants.fromSubjectLinesConfig.buttons.save}
          </Button>
        </div>
      </div>
    </div>
  )
}

export default FromSubjectLinesModal



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\modals\index.ts
================================================================================

export { default as FileUploadModal } from './FileUploadModal'
export type { UploadType } from './FileUploadModal'
export { default as FromSubjectLinesModal } from './FromSubjectLinesModal'
export { default as SingleCreativeView } from './SingleCreativeView'
export { default as MultipleCreativeView } from './MultipleCreativeView'



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\modals\MultipleCreativeView.tsx
================================================================================

"use client";

import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  FileText,
  Image,
  File,
  Minimize2,
  FileArchive,
  Sparkles,
} from "lucide-react";
import { formatFileSize, getFileType } from "@/constants";
import SingleCreativeView from "./SingleCreativeView";
import { proofreadTextClaude, proofreadImageGPT } from "@/lib/proofreadClient";
import { ProofreadResult } from "@/types/proofread";
import { renameCreative } from "@/lib/creativeClient";
import { ImagePreview } from "@/components/ui/ImagePreview";
import { bulkDeleteByIds, parseIdsFromUrl } from "@/lib/filesClient";

interface MultipleCreativeViewProps {
  isOpen: boolean;
  onClose: () => void;
  creatives: Array<{
    id: string;
    name: string;
    url: string;
    size: number;
    type: string;
    previewUrl?: string;
    html?: boolean;
  }>;
  zipFileName?: string;
  onRemoveCreative?: (creativeId: string) => void;
  onFileNameChange?: (fileId: string, newFileName: string) => void;
}

const MultipleCreativeView: React.FC<MultipleCreativeViewProps> = ({
  isOpen,
  onClose,
  creatives,
  zipFileName,
  onRemoveCreative,
  onFileNameChange,
}) => {
  const [currentCreativeIndex, setCurrentCreativeIndex] = useState(0);
  const [isHtmlEditorFullscreen, setIsHtmlEditorFullscreen] = useState(false);
  const [isImagePreviewFullscreen, setIsImagePreviewFullscreen] =
    useState(false);

  // Proofreading state
  const [proofreadingResults, setProofreadingResults] = useState<
    Record<string, ProofreadResult>
  >({});
  const [isProofreading, setIsProofreading] = useState(false);

  // SingleCreativeView state
  const [isSingleCreativeViewOpen, setIsSingleCreativeViewOpen] =
    useState(false);
  const [selectedCreative, setSelectedCreative] = useState<
    MultipleCreativeViewProps["creatives"][0] | null
  >(null);

  // HTML content state for editing
  const [htmlContent, setHtmlContent] = useState("");

  // CRUD operations state
  const [isDeleting, setIsDeleting] = useState<string | null>(null);
  const [isRenaming, setIsRenaming] = useState<string | null>(null);
  const [editingName, setEditingName] = useState<string>("");

  // Current creative
  const currentCreative = creatives[currentCreativeIndex];

  // Prevent background scrolling when modal is open
  React.useEffect(() => {
    if (isOpen) {
      // Store current scroll position
      const scrollY = window.scrollY;
      document.body.style.position = "fixed";
      document.body.style.top = `-${scrollY}px`;
      document.body.style.width = "100%";
      document.body.style.overflow = "hidden";
    } else {
      // Restore scroll position and body styles
      const scrollY = document.body.style.top;
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.width = "";
      document.body.style.overflow = "";
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY || "0") * -1);
      }
    }

    // Cleanup function to restore scrolling when component unmounts
    return () => {
      const scrollY = document.body.style.top;
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.width = "";
      document.body.style.overflow = "";
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY || "0") * -1);
      }
    };
  }, [isOpen]);

  // Load HTML content when creative changes for HTML creatives
  React.useEffect(() => {
    if (
      isOpen &&
      currentCreative &&
      (currentCreative.type?.includes("html") ||
        currentCreative.name.toLowerCase().includes(".html"))
    ) {
      console.log("Loading HTML content for HTML creative...");
      fetchHtmlContent();
    }
  }, [isOpen, currentCreative]); // fetchHtmlContent is defined inline and doesn't need to be a dependency

  // Function to fetch HTML content from uploaded file
  const fetchHtmlContent = async () => {
    if (!currentCreative) return;

    try {
      console.log("Fetching HTML content from:", currentCreative.url);

      // First, try to get the file content from our API endpoint
      const encodedFileUrl = encodeURIComponent(currentCreative.url);
      const apiResponse = await fetch(
        `/api/get-file-content?fileId=${currentCreative.id}&fileUrl=${encodedFileUrl}&processAssets=true`,
        {
          method: "GET",
          headers: {
            Accept:
              "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
          },
        }
      );

      if (apiResponse.ok) {
        const htmlText = await apiResponse.text();
        console.log("HTML content loaded via API, length:", htmlText.length);
        setHtmlContent(htmlText);
        return;
      } else {
        console.log("API response not OK, status:", apiResponse.status);
      }

      // If API fails, try to fetch directly from the uploaded URL
      console.log("API failed, trying direct URL fetch...");
      const directResponse = await fetch(currentCreative.url, {
        method: "GET",
        headers: {
          Accept:
            "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        },
        mode: "cors",
      });

      if (directResponse.ok) {
        const htmlText = await directResponse.text();
        console.log("HTML content loaded directly, length:", htmlText.length);
        setHtmlContent(htmlText);
      } else {
        // Final fallback
        console.log("All methods failed, using fallback content");
        setHtmlContent(`<!-- HTML Content Loading Failed -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Creative Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }
        .message {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #ff6b6b;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="message">
        <h3>âš ï¸ Unable to load original HTML content</h3>
        <p>You can start editing by replacing this content with your HTML code.</p>
    </div>
</body>
</html>`);
      }
    } catch (error) {
      console.log("Fetch error, using fallback content...");
      console.error("Error details:", error);
      setHtmlContent(`<!-- HTML Content Loading Failed -->
<!DOCTYPE html>
<html>
<body>
    <div style="padding: 20px; font-family: Arial, sans-serif;">
        <h3>âš ï¸ Unable to load HTML content</h3>
        <p>Please try refreshing or contact support.</p>
    </div>
</body>
</html>`);
    }
  };

  if (!isOpen) return null;

  const handleSaveHtml = async () => {
    console.log("Saving HTML changes for creative:", currentCreative?.id);
  };

  // HTML Editor fullscreen toggle
  const toggleHtmlEditorFullscreen = () => {
    setIsHtmlEditorFullscreen(!isHtmlEditorFullscreen);
  };

  // Image Preview fullscreen toggle
  const toggleImagePreviewFullscreen = () => {
    setIsImagePreviewFullscreen(!isImagePreviewFullscreen);
  };

  // SingleCreativeView handlers
  const openSingleCreativeView = (
    creative: MultipleCreativeViewProps["creatives"][0]
  ) => {
    setSelectedCreative(creative);
    setIsSingleCreativeViewOpen(true);
  };

  const closeSingleCreativeView = () => {
    setIsSingleCreativeViewOpen(false);
    setSelectedCreative(null);
  };

  const handleFileNameChangeFromSingle = (
    fileId: string,
    newFileName: string
  ) => {
    // Update the creative in the creatives array
    const updatedCreatives = creatives.map((creative) =>
      creative.id === fileId ? { ...creative, name: newFileName } : creative
    );

    // Update selected creative if it's the one being edited
    if (selectedCreative?.id === fileId) {
      setSelectedCreative({ ...selectedCreative, name: newFileName });
    }

    // Propagate the change to parent component
    onFileNameChange?.(fileId, newFileName);
  };

  // CRUD operations
  const handleDeleteCreative = async (creative: (typeof creatives)[0]) => {
    if (!confirm(`Are you sure you want to delete "${creative.name}"?`)) {
      return;
    }

    try {
      setIsDeleting(creative.id);
      
      const ids = new Set<string>();
      ids.add(creative.id);
      
      if (creative.previewUrl) {
        const previewId = parseIdsFromUrl(creative.previewUrl).id;
        if (previewId) ids.add(previewId);
      }
      
      await bulkDeleteByIds(Array.from(ids));

      onRemoveCreative?.(creative.id);

      if (currentCreative?.id === creative.id && creatives.length > 1) {
        const currentIndex = creatives.findIndex((c) => c.id === creative.id);
        const nextIndex =
          currentIndex === creatives.length - 1
            ? currentIndex - 1
            : currentIndex + 1;
        setCurrentCreativeIndex(nextIndex);
      }
    } catch (error) {
      console.error("Failed to delete creative:", error);
    } finally {
      setIsDeleting(null);
    }
  };

  const handleRenameCreative = async (
    creative: (typeof creatives)[0],
    newName: string
  ) => {
    if (!newName.trim() || newName === creative.name) {
      setIsRenaming(null);
      setEditingName("");
      return;
    }

    try {
      setIsRenaming(creative.id);
      await renameCreative({
        creativeId: creative.id,
        fileUrl: creative.url,
        newName: newName.trim(),
      });

      // Update local state
      onFileNameChange?.(creative.id, newName.trim());

      // Update selected creative if it's the one being renamed
      if (selectedCreative?.id === creative.id) {
        setSelectedCreative({ ...selectedCreative, name: newName.trim() });
      }
    } catch (error) {
      console.error("Failed to rename creative:", error);
    } finally {
      setIsRenaming(null);
      setEditingName("");
    }
  };

  // Proofreading function for individual creatives
  const handleProofreadCreative = async (creative: (typeof creatives)[0]) => {
    try {
      setIsProofreading(true);
      console.log("Starting proofreading for creative:", creative.id);

      let result: ProofreadResult;

      const isHtml = creative.html || creative.type === "html" || /\.html?$/i.test(creative.name);
      const isImg = creative.type === "image" || /^image\//.test(creative.type);

      if (isHtml) {
        try {
          const response = await fetch(
            `/api/get-file-content?fileId=${
              creative.id
            }&fileUrl=${encodeURIComponent(creative.url)}&processAssets=true`
          );
          if (response.ok) {
            const htmlContent = await response.text();
            result = await proofreadTextClaude(htmlContent);
          } else {
            throw new Error("Failed to fetch HTML content");
          }
        } catch (error) {
          console.error("Failed to proofread HTML:", error);
          result = { corrected: "", edits: [] };
        }
      } else if (isImg) {
        const raw = creative.previewUrl || creative.url;
        const imageUrl = raw ? new URL(raw, window.location.origin).toString() : "";
        
        result = await proofreadImageGPT(imageUrl);
      } else {
        console.log(
          "Unsupported creative type for proofreading:",
          creative.type
        );
        result = { corrected: "", edits: [] };
      }

      setProofreadingResults((prev) => ({
        ...prev,
        [creative.id]: result,
      }));
    } catch (error) {
      console.error("Proofreading failed:", error);
      setProofreadingResults((prev) => ({
        ...prev,
        [creative.id]: { corrected: "", edits: [] },
      }));
    } finally {
      setIsProofreading(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 animate-in fade-in duration-200">
      <div className="bg-white w-full h-full flex flex-col animate-in zoom-in-95 duration-200">
        {/* Header - Single Row Layout */}
        <div className="flex items-center justify-between p-4 sm:p-6 border-b border-gray-200 bg-gradient-to-r from-purple-50 to-blue-50 gap-3 sm:gap-4">
          <div className="flex items-center gap-2 sm:gap-4 min-w-0 flex-1">
            <div className="p-2 sm:p-3 bg-purple-100 rounded-xl shadow-sm flex-shrink-0">
              <FileArchive className="h-5 w-5 sm:h-6 sm:w-6 text-purple-600" />
            </div>
            <div className="min-w-0 flex-1">
              <h2 className="text-sm sm:text-lg lg:text-xl font-semibold text-gray-900 mb-0.5 sm:mb-1 truncate">
                {zipFileName || "Multiple Creatives"}
              </h2>
              <div className="flex items-center gap-1 sm:gap-2">
                <span className="inline-flex items-center px-1.5 sm:px-2 py-0.5 sm:py-1 rounded-full text-xs font-medium bg-purple-100 text-purple-800">
                  {creatives.length} files
                </span>
                <span className="text-gray-600 text-xs">â€¢</span>
                <span className="text-xs text-gray-600">ZIP Archive</span>
              </div>
            </div>
          </div>

          <Button
            variant="default"
            size="sm"
            onClick={onClose}
            className="px-3 sm:px-4 lg:px-6 py-1.5 sm:py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg shadow-sm transition-all duration-150 hover:shadow-md text-xs sm:text-sm flex-shrink-0"
          >
            <span>Save and Continue</span>
          </Button>
        </div>

        {/* Content - Responsive Card Layout */}
        <div className="flex-1 overflow-hidden">
          <div className="h-full p-3 sm:p-4 lg:p-6 bg-gray-50 overflow-y-auto">
            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6 gap-3 sm:gap-4">
              {creatives.map((creative) => {
                const fileType = getFileType(creative.name);
                const isImage = fileType === "image";
                const isHtml = fileType === "html";



                return (
                  <div
                    key={creative.id}
                    className="bg-white rounded-lg border border-gray-200 shadow-sm hover:shadow-md hover:border-blue-200 transition-all duration-200 overflow-hidden group"
                  >
                    {/* Preview Section */}
                    <div className="aspect-[4/3] bg-gray-50 overflow-hidden relative">
                      {isImage ? (
                        <ImagePreview
                          src={creative.previewUrl || creative.url}
                          alt={creative.name}
                          fileName={creative.name}
                          className="w-full h-full object-cover"
                        />
                      ) : isHtml ? (
                        <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-emerald-50 to-green-50">
                          <div className="text-center">
                            <FileText className="h-10 w-10 text-emerald-600 mx-auto mb-2" />
                            <p className="text-xs font-medium text-emerald-700">
                              HTML
                            </p>
                          </div>
                        </div>
                      ) : (
                        <div className="w-full h-full flex items-center justify-center bg-gradient-to-br from-slate-50 to-gray-50">
                          <div className="text-center">
                            <File className="h-10 w-10 text-slate-500 mx-auto mb-2" />
                            <p className="text-xs font-medium text-slate-600">
                              File
                            </p>
                          </div>
                        </div>
                      )}

                      {/* Action Buttons - Top Right */}
                      <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex gap-1">
                        {/* Rename Button */}
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            setEditingName(creative.name);
                            setIsRenaming(creative.id);
                          }}
                          disabled={isRenaming === creative.id}
                          className="h-6 sm:h-7 px-1.5 sm:px-2 bg-white/95 border-blue-200 text-blue-600 hover:bg-blue-50 hover:text-blue-700 hover:border-blue-300 text-xs font-medium shadow-sm"
                        >
                          <span className="hidden sm:inline">Rename</span>
                          <span className="sm:hidden">âœï¸</span>
                        </Button>

                        {/* Delete Button */}
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDeleteCreative(creative);
                          }}
                          disabled={isDeleting === creative.id}
                          className="h-6 sm:h-7 px-1.5 sm:px-2 bg-white/95 border-red-200 text-red-600 hover:bg-red-50 hover:text-red-700 hover:border-red-300 text-xs font-medium shadow-sm"
                        >
                          {isDeleting === creative.id ? (
                            <div className="w-3 h-3 border border-red-600 border-t-transparent rounded-full animate-spin" />
                          ) : (
                            <>
                              <span className="hidden sm:inline">Delete</span>
                              <span className="sm:hidden">Ã—</span>
                            </>
                          )}
                        </Button>
                      </div>
                    </div>

                    {/* Content Section */}
                    <div className="p-3 sm:p-4">
                      {/* Filename and File Info */}
                      <div className="mb-3">
                        {isRenaming === creative.id ? (
                          <div className="flex gap-1 mb-2">
                            <input
                              type="text"
                              value={editingName}
                              onChange={(e) => setEditingName(e.target.value)}
                              onKeyDown={(e) => {
                                if (e.key === "Enter") {
                                  handleRenameCreative(creative, editingName);
                                } else if (e.key === "Escape") {
                                  setIsRenaming(null);
                                  setEditingName("");
                                }
                              }}
                              className="flex-1 text-xs sm:text-sm border border-blue-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                              autoFocus
                            />
                            <Button
                              size="sm"
                              onClick={() =>
                                handleRenameCreative(creative, editingName)
                              }
                              disabled={isRenaming === creative.id}
                              className="h-6 sm:h-7 px-2 bg-blue-600 hover:bg-blue-700 text-white text-xs"
                            >
                              {isRenaming === creative.id ? (
                                <div className="w-3 h-3 border border-white border-t-transparent rounded-full animate-spin" />
                              ) : (
                                "âœ“"
                              )}
                            </Button>
                            <Button
                              size="sm"
                              variant="outline"
                              onClick={() => {
                                setIsRenaming(null);
                                setEditingName("");
                              }}
                              className="h-6 sm:h-7 px-2 border-gray-300 text-gray-600 hover:bg-gray-50 text-xs"
                            >
                              Ã—
                            </Button>
                          </div>
                        ) : (
                          <h3
                            className="font-medium text-gray-900 text-xs sm:text-sm truncate mb-1"
                            title={creative.name}
                          >
                            {creative.name}
                          </h3>
                        )}
                        <div className="flex items-center justify-between text-xs text-gray-500">
                          <span
                            className={`inline-flex items-center px-1.5 sm:px-2 py-0.5 rounded-full font-medium text-xs ${
                              isImage
                                ? "bg-blue-50 text-blue-600"
                                : isHtml
                                ? "bg-emerald-50 text-emerald-600"
                                : "bg-gray-50 text-gray-600"
                            }`}
                          >
                            {fileType}
                          </span>
                          <span className="font-medium text-xs">
                            {formatFileSize(creative.size)}
                          </span>
                        </div>
                      </div>

                      {/* View Button */}
                      <Button
                        onClick={() => {
                          openSingleCreativeView(creative);
                        }}
                        className="w-full bg-blue-400 hover:bg-blue-600 text-white font-medium py-1.5 sm:py-2 px-2 sm:px-3 rounded-md text-xs sm:text-sm transition-colors duration-200 mb-2"
                      >
                        <span>View Creative</span>
                      </Button>

                      <Button
                        onClick={() => handleProofreadCreative(creative)}
                        disabled={isProofreading}
                        variant="outline"
                        size="sm"
                        className="w-full border-purple-200 text-purple-600 hover:bg-purple-50 hover:text-purple-700 hover:border-purple-300 text-xs font-medium py-1.5 sm:py-2 px-2 sm:px-3 transition-colors duration-200"
                      >
                        <Sparkles className="h-3 w-3 sm:h-4 sm:w-4 mr-1" />
                        <span>
                          {isProofreading ? "Analyzing..." : "Proofread"}
                        </span>
                      </Button>

                      {proofreadingResults[creative.id] && (
                        <div className="mt-2 p-2 bg-purple-50 border border-purple-200 rounded-md">
                          <div className="text-xs text-purple-800">
                            <div className="font-medium mb-1">
                              Issues:{" "}
                              {proofreadingResults[creative.id].edits?.length ||
                                0}
                            </div>
                            {proofreadingResults[creative.id].edits &&
                              proofreadingResults[creative.id].edits.length >
                                0 && (
                                <div className="space-y-1">
                                  {proofreadingResults[creative.id].edits
                                    .slice(0, 2)
                                    .map((edit, index) => (
                                      <div key={index} className="text-xs">
                                        <span className="font-medium">
                                          {edit.severity}:
                                        </span>{" "}
                                        {edit.reason}
                                      </div>
                                    ))}
                                  {proofreadingResults[creative.id].edits
                                    .length > 2 && (
                                    <div className="text-xs text-purple-600">
                                      +
                                      {proofreadingResults[creative.id].edits
                                        .length - 2}{" "}
                                      more
                                    </div>
                                  )}
                                </div>
                              )}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      </div>

      {/* Fullscreen HTML Editor Modal */}
      {isHtmlEditorFullscreen && (
        <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[60] animate-in fade-in duration-200">
          <div className="bg-white w-full h-full flex flex-col shadow-2xl animate-in zoom-in-95 duration-200">
            {/* Fullscreen Header */}
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between p-4 sm:p-6 border-b border-gray-200 gap-3 sm:gap-0">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-orange-100 rounded-lg">
                  <FileText className="h-5 w-5 text-orange-600" />
                </div>
                <h2 className="text-lg sm:text-xl font-semibold text-gray-800 truncate">
                  HTML Editor - {currentCreative?.name}
                </h2>
              </div>

              <div className="flex gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={toggleHtmlEditorFullscreen}
                  className="flex items-center gap-2 text-purple-700 border-purple-300 hover:bg-purple-50 hover:text-purple-800 transition-colors flex-1 sm:flex-initial"
                >
                  <Minimize2 className="h-4 w-4" />
                  Exit Fullscreen
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleSaveHtml}
                  className="flex items-center gap-2 text-orange-700 border-orange-300 hover:bg-orange-50 hover:text-orange-800 transition-colors flex-1 sm:flex-initial"
                >
                  <FileText className="h-4 w-4" />
                  Save Changes
                </Button>
              </div>
            </div>

            {/* Fullscreen Content - Responsive Split View */}
            <div className="flex-1 flex flex-col lg:flex-row overflow-hidden">
              {/* HTML Editor */}
              <div className="lg:w-1/2 lg:border-r border-gray-200 flex flex-col min-h-0">
                <div className="p-3 sm:p-4 border-b border-gray-200">
                  <Label className="text-xs sm:text-sm font-semibold text-gray-700 uppercase tracking-wide">
                    HTML Code
                  </Label>
                </div>
                <div className="flex-1 p-3 sm:p-4">
                  <Textarea
                    value={htmlContent}
                    onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
                      setHtmlContent(e.target.value)
                    }
                    placeholder="Edit your HTML code here..."
                    className="w-full h-full resize-none text-xs sm:text-sm font-mono border-gray-300 focus:border-orange-500 focus:ring-orange-500/20"
                  />
                </div>
              </div>

              {/* Live Preview */}
              <div className="lg:w-1/2 flex flex-col min-h-0 border-t lg:border-t-0 border-gray-200">
                <div className="p-3 sm:p-4 border-b border-gray-200">
                  <Label className="text-xs sm:text-sm font-semibold text-gray-700 uppercase tracking-wide">
                    Live Preview
                  </Label>
                </div>
                <div className="flex-1 bg-gray-50 min-h-[300px] lg:min-h-0">
                  <iframe
                    srcDoc={
                      htmlContent ||
                      '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font-family:Arial,sans-serif;color:#666;"><p>HTML content will appear here</p></div>'
                    }
                    title="HTML Preview - Fullscreen"
                    className="w-full h-full border-0"
                    sandbox="allow-scripts allow-same-origin"
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Fullscreen Image Preview Modal */}
      {isImagePreviewFullscreen &&
        currentCreative &&
        getFileType(currentCreative.name) === "image" &&
        (currentCreative.previewUrl || currentCreative.url) && (
          <div className="fixed inset-0 bg-black bg-opacity-95 flex items-center justify-center z-[60] animate-in fade-in duration-200">
            <div className="relative w-full h-full flex items-center justify-center p-4 sm:p-8">
              {/* Exit Fullscreen Button */}
              <Button
                variant="outline"
                size="sm"
                onClick={toggleImagePreviewFullscreen}
                className="absolute top-3 sm:top-6 right-3 sm:right-6 flex items-center gap-2 text-white border-white/30 hover:bg-white/10 hover:text-white transition-colors z-10"
              >
                <Minimize2 className="h-4 w-4" />
                <span>Exit Fullscreen</span>
              </Button>

              {/* Header with filename */}
              <div className="absolute top-3 sm:top-6 left-3 sm:left-6 flex items-center gap-3 text-white z-10">
                <div className="p-2 bg-white/20 rounded-lg backdrop-blur-sm">
                  <Image className="h-4 w-4 sm:h-5 sm:w-5" />
                </div>
                <h2 className="text-sm sm:text-lg font-semibold truncate max-w-[200px] sm:max-w-none">
                  {currentCreative?.name}
                </h2>
              </div>

              {/* Fullscreen Image */}
              <div onClick={(e) => e.stopPropagation()}>
                <ImagePreview
                  src={currentCreative?.previewUrl || currentCreative?.url}
                  alt={currentCreative?.name}
                  fileName={currentCreative?.name}
                  className="max-w-[90vw] max-h-[80vh] object-contain rounded-lg shadow-2xl"
                />
              </div>

              {/* Click outside to close */}
              <div
                className="absolute inset-0 cursor-pointer"
                onClick={toggleImagePreviewFullscreen}
              />
            </div>
          </div>
        )}

      {/* SingleCreativeView Modal */}
      {selectedCreative && (
        <SingleCreativeView
          isOpen={isSingleCreativeViewOpen}
          onClose={closeSingleCreativeView}
          creative={selectedCreative}
          onFileNameChange={handleFileNameChangeFromSingle}
        />
      )}
    </div>
  );
};

export default MultipleCreativeView;



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\modals\SingleCreativeView.tsx
================================================================================

"use client";

import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Edit3,
  Eye,
  FileText,
  Image,
  File,
  Sparkles,
  Maximize2,
  Minimize2,
  Check,
  X,
  ChevronUp,
  ChevronDown,
} from "lucide-react";
import { formatFileSize, getFileType } from "@/constants";
import { Constants } from "@/app/Constants/Constants";
import { proofreadCreative } from "@/lib/proofreadCreativeClient";
import { saveHtml, renameCreative } from "@/lib/creativeClient";
import { ImagePreview } from "@/components/ui/ImagePreview";
import { generateEmailContent } from "@/lib/generationClient";

interface SingleCreativeViewProps {
  isOpen: boolean;
  onClose: () => void;
  creative: {
    id: string;
    name: string;
    url: string;
    size: number;
    type: string;
    previewUrl?: string;
    html?: boolean;
  };
  onFileNameChange?: (fileId: string, newFileName: string) => void;
}

const SingleCreativeView: React.FC<SingleCreativeViewProps> = ({
  isOpen,
  onClose,
  creative,
  onFileNameChange,
}) => {
  const [editableFileName, setEditableFileName] = useState(creative.name);
  const [editableNameOnly, setEditableNameOnly] = useState(() => {
    const lastDotIndex = creative.name.lastIndexOf(".");
    return lastDotIndex > 0
      ? creative.name.substring(0, lastDotIndex)
      : creative.name;
  });
  const [isEditing, setIsEditing] = useState(false);
  const [fromLines, setFromLines] = useState("");
  const [subjectLines, setSubjectLines] = useState("");
  const [isHtmlEditorFullscreen, setIsHtmlEditorFullscreen] = useState(false);
  const [isImagePreviewFullscreen, setIsImagePreviewFullscreen] =
    useState(false);
  const [isHtmlPreviewFullscreen, setIsHtmlPreviewFullscreen] = useState(false);
  const [isPreviewCollapsed, setIsPreviewCollapsed] = useState(false);

  // Proofreading data state
  const [proofreadingData, setProofreadingData] = useState<{
    issues: Array<{
      icon: string;
      type: string;
      original?: string;
      correction?: string;
      note?: string;
    }>;
    suggestions: Array<{
      icon: string;
      type: string;
      description: string;
    }>;
    qualityScore: {
      grammar: number;
      readability: number;
      conversion: number;
      brandAlignment: number;
    };
  }>({
    issues: [],
    suggestions: [],
    qualityScore: {
      grammar: 0,
      readability: 0,
      conversion: 0,
      brandAlignment: 0,
    },
  });

  // HTML content state for editing
  const [htmlContent, setHtmlContent] = useState("");

  // HTML Editor state
  const [isSaving, setIsSaving] = useState(false);
  const [previewKey, setPreviewKey] = useState(0);

  // Content generation state
  const [isGeneratingContent, setIsGeneratingContent] = useState(false);

  // Prevent background scrolling when modal is open
  React.useEffect(() => {
    if (isOpen) {
      // Store current scroll position
      const scrollY = window.scrollY;
      document.body.style.position = "fixed";
      document.body.style.top = `-${scrollY}px`;
      document.body.style.width = "100%";
      document.body.style.overflow = "hidden";
    } else {
      // Restore scroll position and body styles
      const scrollY = document.body.style.top;
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.width = "";
      document.body.style.overflow = "";
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY || "0") * -1);
      }
    }

    // Cleanup function to restore scrolling when component unmounts
    return () => {
      const scrollY = document.body.style.top;
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.width = "";
      document.body.style.overflow = "";
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY || "0") * -1);
      }
    };
  }, [isOpen]);

  // Function to fetch HTML content from uploaded file
  const fetchHtmlContent = React.useCallback(async () => {
    try {
      console.log("Fetching HTML content from:", creative.url);
      console.log("Creative type:", creative.type);
      console.log("Creative name:", creative.name);
      console.log("Creative ID:", creative.id);

      // First, try to get the file content from our API endpoint with asset processing
      console.log("Trying API endpoint with asset processing...");
      const encodedFileUrl = encodeURIComponent(creative.url);
      const apiResponse = await fetch(
        `/api/get-file-content?fileId=${creative.id}&fileUrl=${encodedFileUrl}&processAssets=true`,
        {
          method: "GET",
          headers: {
            Accept:
              "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
          },
        }
      );

      if (apiResponse.ok) {
        const htmlText = await apiResponse.text();
        console.log("HTML content loaded via API, length:", htmlText.length);
        console.log("First 200 characters:", htmlText.substring(0, 200));
        setHtmlContent(htmlText);
        return;
      } else {
        console.log("API response not OK, status:", apiResponse.status);
        const errorText = await apiResponse.text();
        console.log("API error response:", errorText);
      }

      // If API fails, try to fetch directly from the uploaded URL
      console.log("API failed, trying direct URL fetch...");
      const directResponse = await fetch(creative.url, {
        method: "GET",
        headers: {
          Accept:
            "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        },
        mode: "cors",
      });

      console.log("Direct response status:", directResponse.status);

      if (directResponse.ok) {
        const htmlText = await directResponse.text();
        console.log("HTML content loaded directly, length:", htmlText.length);
        console.log("First 200 characters:", htmlText.substring(0, 200));
        setHtmlContent(htmlText);
      } else {
        // Final fallback
        console.log("All methods failed, using fallback content");
        await tryAlternativeHtmlLoading();
      }
    } catch (error) {
      console.log("Fetch error, trying alternative approach...");
      console.error("Error details:", error);
      // Try alternative approach
      await tryAlternativeHtmlLoading();
    }
  }, [creative.url, creative.type, creative.name, creative.id]);

  // Alternative approach to load HTML content
  const tryAlternativeHtmlLoading = async () => {
    console.log("Using fallback HTML content...");
    // Provide a helpful fallback message with instructions
    const fallbackContent = `<!-- HTML Content Loading Failed -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Creative Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
            color: #333;
        }
        .message {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #ff6b6b;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="message">
        <h3>âš ï¸ Unable to load original HTML content</h3>
        <p>You can start editing by replacing this content with your HTML code.</p>
        <p><strong>Tips:</strong></p>
        <ul>
            <li>Paste your HTML code directly into the editor</li>
            <li>The preview will update automatically as you type</li>
            <li>Click "Save Changes" to save your edits</li>
            <li>Click "Refresh Content" to try loading the original file again</li>
        </ul>
    </div>
</body>
</html>`;

    setHtmlContent(fallbackContent);
  };

  // Load HTML content when modal opens for HTML creatives
  React.useEffect(() => {
    if (
      isOpen &&
      creative.type &&
      (creative.type.includes("html") ||
        creative.name.toLowerCase().includes(".html"))
    ) {
      console.log("Loading HTML content for HTML creative...");
      fetchHtmlContent();
    }
  }, [isOpen, creative.type, creative.name, fetchHtmlContent]);

  // HTML Content Loading & Image Hosting implemented with /api/files/[id]/[...path] and asset rewriting

  if (!isOpen) return null;

  const fileType = getFileType(creative.name);
  const isImage = fileType === "image";
  const isHtml = fileType === "html";

  console.log("File type detection:", {
    fileName: creative.name,
    fileType,
    isImage,
    isHtml,
    creativeType: creative.type,
  });

  const handleFileNameSave = async () => {
    // Validate that the name part is not empty
    if (!editableNameOnly.trim()) {
      // Don't save empty names
      return;
    }

    // Construct the full filename with the original extension
    const originalExtension = creative.name.substring(
      creative.name.lastIndexOf(".")
    );
    const newFileName = editableNameOnly.trim() + originalExtension;

    try {
      // Call the rename API
      await renameCreative({
        creativeId: creative.id,
        fileUrl: creative.url,
        newName: newFileName,
      });

      // Update both state variables
      setEditableFileName(newFileName);

      // Update the creative object to reflect changes everywhere
      creative.name = newFileName;

      // Notify parent component about filename change
      onFileNameChange?.(creative.id, newFileName);

      console.log("Filename renamed successfully:", newFileName);
    } catch (error) {
      console.error("Failed to rename file:", error);
      // Revert to original name on error
      setEditableFileName(creative.name);
      const lastDotIndex = creative.name.lastIndexOf(".");
      setEditableNameOnly(
        lastDotIndex > 0
          ? creative.name.substring(0, lastDotIndex)
          : creative.name
      );
      // You can add toast notification here for error feedback
    } finally {
      setIsEditing(false);
    }
  };

  const handleFileNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const nameOnly = e.target.value;
    setEditableNameOnly(nameOnly);

    // Update the full filename with extension
    const extension = creative.name.substring(creative.name.lastIndexOf("."));
    setEditableFileName(nameOnly + extension);
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      handleFileNameSave();
    } else if (e.key === "Escape") {
      setEditableFileName(creative.name);
      const lastDotIndex = creative.name.lastIndexOf(".");
      setEditableNameOnly(
        lastDotIndex > 0
          ? creative.name.substring(0, lastDotIndex)
          : creative.name
      );
      setIsEditing(false);
    }
  };

  // LLM Content Generation implemented with /api/generate-email-content endpoint
  //   "success": true,
  //   "fromLines": [
  //     "Sarah from TechCorp",
  //     "Your TechCorp Success Team",
  //     "TechCorp Customer Success"
  //   ],
  //   "subjectLines": [
  //     "Transform your business with TechCorp",
  //     "The secret to 10x productivity",
  //     "Don't miss: 50% off this week only",
  //     "Free trial: See results in 7 days"
  //   ]
  // }
  const handleGenerateContent = async () => {
    try {
      setIsGeneratingContent(true);
      console.log("Generating email content for creative:", creative.id);

      let sampleText = "";
      if (creative.type === "html" || creative.html) {
        if (htmlContent) {
          sampleText = htmlContent
            .replace(/<[^>]*>/g, " ")
            .replace(/\s+/g, " ")
            .trim()
            .slice(0, 1000);
        }
      } else if (creative.type === "image") {
        sampleText = `Image creative: ${creative.name}`;
      }

      const { fromLines: newFromLines, subjectLines: newSubjectLines } =
        await generateEmailContent({
          creativeType: creative.type || "Email",
          notes: "",
          sampleText,
          maxFrom: 4,
          maxSubject: 8,
        });

      const mergeContent = (existing: string, newItems: string[]) => {
        const existingLines = existing
          .split("\n")
          .map((s) => s.trim())
          .filter(Boolean);
        const newLines = newItems.map((s) => s.trim()).filter(Boolean);
        const allLines = [...existingLines, ...newLines];
        const uniqueLines = Array.from(new Set(allLines));
        return uniqueLines.join("\n");
      };

      setFromLines((prev) => mergeContent(prev, newFromLines));
      setSubjectLines((prev) => mergeContent(prev, newSubjectLines));

      console.log("Content generation completed successfully");
    } catch (error) {
      console.error("Content generation failed:", error);
      setFromLines("Failed to generate content. Please try again.");
      setSubjectLines("Failed to generate content. Please try again.");
    } finally {
      setIsGeneratingContent(false);
    }
  };

  // Proofreading Functions
  const handleRegenerateAnalysis = async () => {
    try {
      console.log("Starting proofreading analysis for creative:", creative.id);

      const isHtml = creative.html || creative.type === "html" || /\.html?$/i.test(creative.name);
      const isImg = creative.type === "image" || /^image\//.test(creative.type);

      if (isHtml) {
        if (!htmlContent) {
          console.log("No HTML content available for proofreading");
          return;
        }
        const result = await proofreadCreative({
          fileType: "html",
          htmlContent,
          creativeType: creative.type as
            | "email"
            | "display"
            | "search"
            | "social"
            | "native"
            | "push",
        });
        setProofreadingData(result);
      } else if (isImg) {
        let imageUrl = creative.previewUrl || creative.url;
        if (!imageUrl) {
          console.log("No image URL available for proofreading");
          return;
        }
        
        if (imageUrl && imageUrl.startsWith('/')) {
          imageUrl = `${window.location.origin}${imageUrl}`;
        }
        
        const result = await proofreadCreative({
          fileType: "image",
          fileUrl: imageUrl,
          creativeType: creative.type as
            | "email"
            | "display"
            | "search"
            | "social"
            | "native"
            | "push",
        });
        setProofreadingData(result);
      } else {
        console.log(
          "Unsupported creative type for proofreading:",
          creative.type
        );
        return;
      }

      console.log("Proofreading completed");
    } catch (error) {
      console.error("Proofreading failed:", error);
      setProofreadingData({
        issues: [],
        suggestions: [
          {
            icon: "â„¹ï¸",
            type: "Notice",
            description: "Proofreading failed. Please try again.",
          },
        ],
        qualityScore: {
          grammar: 0,
          readability: 0,
          conversion: 0,
          brandAlignment: 0,
        },
      });
    }
  };

  // HTML Editor Functions
  const handleSaveHtml = async () => {
    try {
      setIsSaving(true);
      console.log("Saving HTML changes for creative:", creative.id);

      await saveHtml({
        fileUrl: creative.url,
        html: htmlContent,
        newFileName: creative.name,
      });

      // Reload iframe preview to show updated content
      setPreviewKey((prev) => prev + 1);

      // Show success feedback (you can add a toast notification here)
      console.log("HTML saved successfully");
    } catch (error) {
      console.error("Failed to save HTML:", error);
      // Show error feedback (you can add a toast notification here)
    } finally {
      setIsSaving(false);
    }
  };

  // File Deletion & Cleanup implemented with /api/files/[id] and /api/files/bulk-delete endpoints

  // HTML Editor fullscreen toggle
  const toggleHtmlEditorFullscreen = () => {
    setIsHtmlEditorFullscreen(!isHtmlEditorFullscreen);
  };

  // HTML Preview fullscreen toggle
  const toggleHtmlPreviewFullscreen = () => {
    setIsHtmlPreviewFullscreen(!isHtmlPreviewFullscreen);
  };

  // Image Preview fullscreen toggle
  const toggleImagePreviewFullscreen = () => {
    setIsImagePreviewFullscreen(!isImagePreviewFullscreen);
  };

  // Preview collapse toggle
  const togglePreviewCollapse = () => {
    setIsPreviewCollapsed(!isPreviewCollapsed);
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 animate-in fade-in duration-200">
      <div className="bg-white w-full h-full flex flex-col animate-in zoom-in-95 duration-200">
        {/* Header with File Details - Left-Right Layout */}
        <div className="flex items-center justify-between p-3 sm:p-4 lg:p-6 border-b border-color-border bg-gray-50 gap-3 sm:gap-4 lg:gap-6">
          {/* Left Side: File Information Group */}
          <div className="flex items-center gap-2 sm:gap-3 min-w-0 flex-1">
            {/* File Icon */}
            <div className="flex-shrink-0">
              {isImage ? (
                <Image className="h-5 w-5 sm:h-6 sm:w-6 text-blue-500" />
              ) : isHtml ? (
                <FileText className="h-5 w-5 sm:h-6 sm:w-6 text-green-500" />
              ) : (
                <File className="h-5 w-5 sm:h-6 sm:w-6 text-gray-500" />
              )}
            </div>

            {/* Filename Section */}
            <div className="min-w-0">
              {isEditing ? (
                <div className="flex items-center gap-1 sm:gap-2">
                  <div className="flex items-center">
                    <Input
                      value={editableNameOnly}
                      onChange={handleFileNameChange}
                      onKeyDown={handleKeyDown}
                      className="text-xs sm:text-sm font-medium h-6 sm:h-7 w-24 sm:w-32 md:w-40 rounded-r-none border-r-0"
                      autoFocus
                      placeholder="Filename"
                    />
                    <span className="text-xs text-gray-500 font-mono px-1 sm:px-2 py-1 h-6 sm:h-7 bg-gray-100 rounded-r border border-l-0 border-gray-300 flex items-center whitespace-nowrap">
                      {creative.name.substring(creative.name.lastIndexOf("."))}
                    </span>
                  </div>
                  <Button
                    variant="default"
                    size="sm"
                    onClick={handleFileNameSave}
                    className="p-1 h-6 w-6 sm:h-7 sm:w-7 bg-green-600 hover:bg-green-700 flex items-center justify-center"
                  >
                    <Check className="h-3 w-3" />
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => {
                      setEditableFileName(creative.name);
                      const lastDotIndex = creative.name.lastIndexOf(".");
                      setEditableNameOnly(
                        lastDotIndex > 0
                          ? creative.name.substring(0, lastDotIndex)
                          : creative.name
                      );
                      setIsEditing(false);
                    }}
                    className="p-1 h-6 w-6 sm:h-7 sm:w-7 border-red-300 text-red-600 hover:bg-red-50 hover:border-red-400 flex items-center justify-center"
                  >
                    <X className="h-3 w-3" />
                  </Button>
                </div>
              ) : (
                <div className="flex items-center gap-1">
                  <span className="text-xs sm:text-sm font-medium text-gray-800 max-w-[120px] sm:max-w-[160px] md:max-w-[200px] truncate">
                    {editableFileName}
                  </span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => {
                      const lastDotIndex = editableFileName.lastIndexOf(".");
                      setEditableNameOnly(
                        lastDotIndex > 0
                          ? editableFileName.substring(0, lastDotIndex)
                          : editableFileName
                      );
                      setIsEditing(true);
                    }}
                    className="p-0.5 h-5 w-5 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors flex-shrink-0"
                  >
                    <Edit3 className="h-3 w-3" />
                  </Button>
                </div>
              )}
            </div>

            {/* File Metadata Group - On Left Side */}
            <div className="flex items-center gap-1 sm:gap-2 flex-shrink-0">
              <span className="px-1.5 sm:px-2 py-0.5 sm:py-1 bg-purple-100 text-purple-700 text-xs font-medium rounded border border-purple-200">
                {creative.type?.split("/")[1] || "File"}
              </span>
              <span className="px-1.5 sm:px-2 py-0.5 sm:py-1 bg-green-100 text-green-700 text-xs font-medium rounded border border-green-200">
                {formatFileSize(creative.size)}
              </span>
            </div>
          </div>

          {/* Right Side: Save Button */}
          <div className="flex-shrink-0">
            <Button
              variant="default"
              size="sm"
              onClick={onClose}
              className="px-3 sm:px-4 py-1.5 sm:py-2 bg-blue-500 hover:bg-blue-600 text-white transition-colors duration-150 text-xs sm:text-sm"
            >
              <span>Save and Continue</span>
            </Button>
          </div>
        </div>

        {/* Content - Responsive Layout */}
        <div className="flex-1 flex flex-col lg:flex-row overflow-hidden">
          {/* Column 1: Creative Preview - Collapsible on mobile/tablet */}
          <div
            className={`${
              isPreviewCollapsed ? "hidden lg:flex" : "flex"
            } lg:w-1/2 lg:border-r border-color-border p-4 sm:p-6 bg-gray-50 flex-col min-h-0`}
          >
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between pb-3 border-b border-gray-200 mb-5 gap-3 sm:gap-0">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-blue-100 rounded-lg">
                  <Eye className="h-5 w-5 text-blue-600" />
                </div>
                <h3 className="text-lg font-semibold text-gray-800">Preview</h3>
              </div>

              {/* Action buttons */}
              <div className="flex gap-2">
                {/* Collapse/Expand button - Only on mobile/tablet */}
                <Button
                  variant="outline"
                  size="sm"
                  onClick={togglePreviewCollapse}
                  className="lg:hidden flex items-center gap-2 text-gray-700 border-gray-300 hover:bg-gray-50 hover:text-gray-800 transition-colors"
                >
                  <ChevronUp className="h-4 w-4" />
                  <span>Collapse</span>
                </Button>

                {isImage && (creative.previewUrl || creative.url) && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={toggleImagePreviewFullscreen}
                    className="flex items-center gap-2 text-blue-700 border-blue-300 hover:bg-blue-50 hover:text-blue-800 transition-colors flex-1 sm:flex-initial"
                  >
                    <Maximize2 className="h-4 w-4" />
                    <span>Fullscreen</span>
                  </Button>
                )}
                {isHtml && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={toggleHtmlPreviewFullscreen}
                    className="flex items-center gap-2 text-green-700 border-green-300 hover:bg-green-50 hover:text-green-800 transition-colors flex-1 sm:flex-initial"
                  >
                    <Maximize2 className="h-4 w-4" />
                    <span>Fullscreen</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-1 bg-white border border-gray-200 rounded-lg overflow-auto min-h-[300px] lg:min-h-0">
              {/* Image preview with fallback to creative.url if previewUrl not available */}
              {isImage && (creative.previewUrl || creative.url) ? (
                <div className="w-full p-4">
                  <ImagePreview
                    src={creative.previewUrl || creative.url}
                    alt={creative.name}
                    fileName={creative.name}
                    className="w-full h-auto rounded-lg shadow-sm"
                  />
                </div>
              ) : isHtml ? (
                <iframe
                  key={previewKey}
                  srcDoc={
                    htmlContent ||
                    '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font-family:Arial,sans-serif;color:#666;"><p>HTML content will appear here</p></div>'
                  }
                  title="HTML Preview"
                  className="w-full h-full border-0"
                  sandbox="allow-scripts allow-same-origin"
                />
              ) : (
                <div className="w-full h-full flex items-center justify-center text-center space-y-3 p-4">
                  <div>
                    <File className="h-16 w-16 text-gray-400 mx-auto mb-3" />
                    <p className="text-gray-600 mb-3">
                      File Preview Not Available
                    </p>
                    <Button
                      variant="outline"
                      onClick={() => window.open(creative.url, "_blank")}
                      className="flex items-center gap-2"
                    >
                      <Eye className="h-4 w-4" />
                      Open File
                    </Button>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Column 2: Features - Expanded when preview collapsed */}
          <div
            className={`${
              isPreviewCollapsed ? "w-full" : "lg:w-1/2"
            } p-4 sm:p-6 overflow-y-auto bg-gray-50 border-t lg:border-t-0 border-color-border lg:border-l-0`}
          >
            <div className="space-y-5">
              <div className="flex items-center justify-between pb-3 border-b border-gray-200">
                <div className="flex items-center gap-3">
                  <div className="p-2 bg-purple-100 rounded-lg">
                    <FileText className="h-5 w-5 text-purple-600" />
                  </div>
                  <h3 className="text-lg font-semibold text-gray-800">
                    Features
                  </h3>
                </div>

                {/* Show expand button when preview is collapsed (mobile/tablet only) */}
                {isPreviewCollapsed && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={togglePreviewCollapse}
                    className="lg:hidden flex items-center gap-2 text-blue-700 border-blue-300 hover:bg-blue-50 hover:text-blue-800 transition-colors"
                  >
                    <ChevronDown className="h-4 w-4" />
                    <span>Show Preview</span>
                  </Button>
                )}
              </div>

              <div className="space-y-4">
                {/* HTML Editor Container - Only show for HTML creatives */}
                {isHtml && (
                  <div className="p-4 sm:p-6 bg-white rounded-lg border border-gray-200 shadow-sm">
                    <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between pb-4 border-b border-gray-200 mb-4 gap-3 sm:gap-0">
                      <div className="flex items-center gap-3">
                        <div className="p-2 bg-orange-100 rounded-lg">
                          <FileText className="h-5 w-5 text-orange-600" />
                        </div>
                        <h3 className="text-sm sm:text-lg font-semibold text-gray-800">
                          HTML Editor
                        </h3>
                      </div>

                      <div className="flex gap-2">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={toggleHtmlEditorFullscreen}
                          className="flex items-center gap-2 text-purple-700 border-purple-300 hover:bg-purple-50 hover:text-purple-800 transition-colors flex-1 sm:flex-initial"
                        >
                          <Maximize2 className="h-4 w-4" />
                          <span className="hidden sm:inline">Fullscreen</span>
                          <span className="sm:hidden">Full</span>
                        </Button>
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={handleSaveHtml}
                          disabled={isSaving}
                          className="flex items-center gap-2 text-orange-700 border-orange-300 hover:bg-orange-50 hover:text-orange-800 transition-colors flex-1 sm:flex-initial disabled:opacity-50"
                        >
                          {isSaving ? (
                            <>
                              <div className="w-4 h-4 border-2 border-orange-700 border-t-transparent rounded-full animate-spin" />
                              <span>Saving...</span>
                            </>
                          ) : (
                            <>
                              <FileText className="h-4 w-4" />
                              <span>Save Changes</span>
                            </>
                          )}
                        </Button>
                      </div>
                    </div>

                    <div className="space-y-4">
                      <div>
                        <Label className="text-xs font-semibold text-gray-600 uppercase tracking-wide mb-2 block">
                          HTML Code
                        </Label>
                        <Textarea
                          value={htmlContent}
                          onChange={(
                            e: React.ChangeEvent<HTMLTextAreaElement>
                          ) => setHtmlContent(e.target.value)}
                          placeholder="Edit your HTML code here..."
                          rows={8}
                          className="w-full resize-none text-xs sm:text-sm font-mono border-gray-500 focus:border-orange-500 focus:ring-orange-500/20"
                        />
                        <p className="text-xs text-gray-500 mt-2">
                          Make changes to your HTML creative. The preview will
                          update automatically.
                        </p>
                      </div>
                    </div>
                  </div>
                )}

                {/* Email Content Group */}
                <div className="p-4 sm:p-6 bg-white rounded-lg border border-gray-200 shadow-sm">
                  <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between pb-4 border-b border-gray-200 mb-4 gap-3 sm:gap-0">
                    <div className="flex items-center gap-3">
                      <div className="p-2 bg-green-100 rounded-lg">
                        <FileText className="h-5 w-5 text-green-600" />
                      </div>
                      <h3 className="text-sm sm:text-lg font-semibold text-gray-800">
                        Email Content
                      </h3>
                    </div>

                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleGenerateContent}
                      disabled={isGeneratingContent}
                      className="flex items-center gap-2 text-green-700 border-green-300 hover:bg-green-50 hover:text-green-800 transition-colors w-full sm:w-auto disabled:opacity-50"
                    >
                      {isGeneratingContent ? (
                        <>
                          <div className="w-4 h-4 border-2 border-green-700 border-t-transparent rounded-full animate-spin" />
                          <span className="hidden sm:inline">
                            Generating...
                          </span>
                          <span className="sm:hidden">Generating...</span>
                        </>
                      ) : (
                        <>
                          <Sparkles className="h-4 w-4" />
                          <span className="hidden sm:inline">
                            Generate From & Subject Lines
                          </span>
                          <span className="sm:hidden">Generate Content</span>
                        </>
                      )}
                    </Button>
                  </div>

                  <div className="space-y-4">
                    {/* From Lines */}
                    <div>
                      <Label className="text-xs font-semibold text-gray-600 uppercase tracking-wide mb-2 block">
                        {Constants.fromSubjectLinesConfig.fromLines.label}
                      </Label>
                      <Textarea
                        value={fromLines}
                        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
                          setFromLines(e.target.value)
                        }
                        placeholder={
                          Constants.fromSubjectLinesConfig.fromLines.placeholder
                        }
                        rows={3}
                        className="w-full resize-none text-xs sm:text-sm border-gray-300 focus:border-blue-500 focus:ring-blue-500/20"
                      />
                      <p className="text-xs text-gray-500 mt-2">
                        {Constants.fromSubjectLinesConfig.fromLines.helpText}
                      </p>
                    </div>

                    {/* Subject Lines */}
                    <div>
                      <Label className="text-xs font-semibold text-gray-600 uppercase tracking-wide mb-2 block">
                        {Constants.fromSubjectLinesConfig.subjectLines.label}
                      </Label>
                      <Textarea
                        value={subjectLines}
                        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
                          setSubjectLines(e.target.value)
                        }
                        placeholder={
                          Constants.fromSubjectLinesConfig.subjectLines
                            .placeholder
                        }
                        rows={3}
                        className="w-full resize-none text-xs sm:text-sm border-gray-300 focus:border-blue-500 focus:ring-blue-500/20"
                      />
                      <p className="text-xs text-gray-500 mt-2">
                        {Constants.fromSubjectLinesConfig.subjectLines.helpText}
                      </p>
                    </div>
                  </div>
                </div>

                {/* Proofreading Container - LLM-based proofreading implemented with /api/proofread-creative */}
                <div className="p-4 sm:p-6 bg-white rounded-lg border border-gray-200 shadow-sm">
                  <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between pb-4 border-b border-gray-200 mb-4 gap-3 sm:gap-0">
                    <div className="flex items-center gap-3">
                      <div className="p-2 bg-amber-100 rounded-lg">
                        <FileText className="h-5 w-5 text-amber-600" />
                      </div>
                      <h3 className="text-sm sm:text-lg font-semibold text-gray-800">
                        Proofreading & Optimization
                      </h3>
                    </div>

                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleRegenerateAnalysis}
                      className="flex items-center gap-2 text-amber-700 border-amber-300 hover:bg-amber-50 hover:text-amber-800 transition-colors w-full sm:w-auto"
                    >
                      <Sparkles className="h-4 w-4" />
                      <span className="hidden sm:inline">Analyze Creative</span>
                      <span className="sm:hidden">Analyze</span>
                    </Button>
                  </div>

                  <div className="space-y-4">
                    {/* Grammar & Spelling Issues */}
                    <div className="space-y-3">
                      <h4 className="text-sm font-semibold text-gray-700 flex items-center gap-2">
                        <span className="w-2 h-2 bg-red-500 rounded-full"></span>
                        Issues Found ({proofreadingData.issues?.length || 0})
                      </h4>

                      <div className="space-y-2">
                        {proofreadingData.issues &&
                        proofreadingData.issues.length > 0 ? (
                          proofreadingData.issues.map(
                            (issue, index: number) => (
                              <div
                                key={index}
                                className="p-3 bg-red-50 border border-red-200 rounded-lg"
                              >
                                <div className="flex items-start gap-2">
                                  <span className="text-sm px-2 py-1 rounded text-xs font-medium bg-red-200 text-red-800">
                                    {issue.type}
                                  </span>
                                  <div className="flex-1">
                                    <p className="text-sm font-medium text-red-800">
                                      {issue.note || issue.type}
                                    </p>
                                    {issue.original && (
                                      <p className="text-xs text-red-600 mt-1">
                                        <span className="line-through">
                                          {issue.original}
                                        </span>
                                      </p>
                                    )}
                                    {issue.correction && (
                                      <p className="text-xs text-green-600 mt-1">
                                        <strong>Correction:</strong>{" "}
                                        {issue.correction}
                                      </p>
                                    )}
                                  </div>
                                </div>
                              </div>
                            )
                          )
                        ) : (
                          <div className="p-4 text-center text-gray-500">
                            <p className="text-sm">
                              No issues found. Your content looks great!
                            </p>
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Suggestions */}
                    {proofreadingData.suggestions &&
                      proofreadingData.suggestions.length > 0 && (
                        <div className="space-y-3">
                          <h4 className="text-sm font-semibold text-gray-700 flex items-center gap-2">
                            <span className="w-2 h-2 bg-blue-500 rounded-full"></span>
                            Suggestions ({proofreadingData.suggestions.length})
                          </h4>
                          <div className="space-y-2">
                            {proofreadingData.suggestions.map(
                              (suggestion, index) => (
                                <div
                                  key={index}
                                  className="p-3 bg-blue-50 border border-blue-200 rounded-lg"
                                >
                                  <div className="flex items-start gap-2">
                                    <span className="text-sm px-2 py-1 rounded text-xs font-medium bg-blue-200 text-blue-800">
                                      {suggestion.type}
                                    </span>
                                    <p className="text-sm text-blue-800">
                                      {suggestion.description}
                                    </p>
                                  </div>
                                </div>
                              )
                            )}
                          </div>
                        </div>
                      )}

                    {/* Quality Score */}
                    {proofreadingData.qualityScore && (
                      <div className="space-y-3">
                        <h4 className="text-sm font-semibold text-gray-700 flex items-center gap-2">
                          <span className="w-2 h-2 bg-purple-500 rounded-full"></span>
                          Quality Score
                        </h4>
                        <div className="grid grid-cols-2 gap-3">
                          <div className="p-3 bg-purple-50 border border-purple-200 rounded-lg text-center">
                            <p className="text-xs text-purple-600 font-medium">
                              Grammar
                            </p>
                            <p className="text-lg font-bold text-purple-800">
                              {proofreadingData.qualityScore.grammar}/100
                            </p>
                          </div>
                          <div className="p-3 bg-purple-50 border border-purple-200 rounded-lg text-center">
                            <p className="text-xs text-purple-600 font-medium">
                              Readability
                            </p>
                            <p className="text-lg font-bold text-purple-800">
                              {proofreadingData.qualityScore.readability}/100
                            </p>
                          </div>
                          <div className="p-3 bg-purple-50 border border-purple-200 rounded-lg text-center">
                            <p className="text-xs text-purple-600 font-medium">
                              Conversion
                            </p>
                            <p className="text-lg font-bold text-purple-800">
                              {proofreadingData.qualityScore.conversion}/100
                            </p>
                          </div>
                          <div className="p-3 bg-purple-50 border border-purple-200 rounded-lg text-center">
                            <p className="text-xs text-purple-600 font-medium">
                              Brand Alignment
                            </p>
                            <p className="text-lg font-bold text-purple-800">
                              {proofreadingData.qualityScore.brandAlignment}/100
                            </p>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Fullscreen HTML Editor Modal */}
      {isHtmlEditorFullscreen && (
        <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[60] animate-in fade-in duration-200">
          <div className="bg-white w-full h-full flex flex-col shadow-2xl animate-in zoom-in-95 duration-200">
            {/* Fullscreen Header */}
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between p-4 sm:p-6 border-b border-gray-200 gap-3 sm:gap-0">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-orange-100 rounded-lg">
                  <FileText className="h-5 w-5 text-orange-600" />
                </div>
                <h2 className="text-lg sm:text-xl font-semibold text-gray-800 truncate">
                  HTML Editor - {creative.name}
                </h2>
              </div>

              <div className="flex gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={toggleHtmlEditorFullscreen}
                  className="flex items-center gap-2 text-purple-700 border-purple-300 hover:bg-purple-50 hover:text-purple-800 transition-colors flex-1 sm:flex-initial"
                >
                  <Minimize2 className="h-4 w-4" />
                  <span>Exit Fullscreen</span>
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleSaveHtml}
                  disabled={isSaving}
                  className="flex items-center gap-2 text-orange-700 border-orange-300 hover:bg-orange-50 hover:text-orange-800 transition-colors flex-1 sm:flex-initial disabled:opacity-50"
                >
                  {isSaving ? (
                    <>
                      <div className="w-4 h-4 border-2 border-orange-700 border-t-transparent rounded-full animate-spin" />
                      <span>Saving...</span>
                    </>
                  ) : (
                    <>
                      <FileText className="h-4 w-4" />
                      <span>Save Changes</span>
                    </>
                  )}
                </Button>
              </div>
            </div>

            {/* Fullscreen Content - Responsive Split View */}
            <div className="flex-1 flex flex-col lg:flex-row overflow-hidden">
              {/* HTML Editor */}
              <div className="lg:w-1/2 lg:border-r border-gray-200 flex flex-col min-h-0">
                <div className="p-3 sm:p-4 border-b border-gray-200">
                  <Label className="text-xs sm:text-sm font-semibold text-gray-700 uppercase tracking-wide">
                    HTML Code
                  </Label>
                </div>
                <div className="flex-1 p-3 sm:p-4">
                  <Textarea
                    value={htmlContent}
                    onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
                      setHtmlContent(e.target.value)
                    }
                    placeholder="Edit your HTML code here..."
                    className="w-full h-full resize-none text-xs sm:text-sm font-mono border-gray-300 focus:border-orange-500 focus:ring-orange-500/20"
                  />
                </div>
              </div>

              {/* Live Preview */}
              <div className="lg:w-1/2 flex flex-col min-h-0 border-t lg:border-t-0 border-gray-200">
                <div className="p-3 sm:p-4 border-b border-gray-200">
                  <Label className="text-xs sm:text-sm font-semibold text-gray-700 uppercase tracking-wide">
                    Live Preview
                  </Label>
                </div>
                <div className="flex-1 bg-gray-50 min-h-[300px] lg:min-h-0">
                  <iframe
                    srcDoc={
                      htmlContent ||
                      '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font-family:Arial,sans-serif;color:#666;"><p>HTML content will appear here</p></div>'
                    }
                    title="HTML Preview - Fullscreen"
                    className="w-full h-full border-0"
                    sandbox="allow-scripts allow-same-origin"
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Fullscreen HTML Preview Modal */}
      {isHtmlPreviewFullscreen && isHtml && (
        <div className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-[60] animate-in fade-in duration-200">
          <div className="bg-white w-full h-full flex flex-col shadow-2xl animate-in zoom-in-95 duration-200">
            {/* Fullscreen Header */}
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between p-4 sm:p-6 border-b border-gray-200 gap-3 sm:gap-0">
              <div className="flex items-center gap-3">
                <div className="p-2 bg-green-100 rounded-lg">
                  <FileText className="h-5 w-5 text-green-600" />
                </div>
                <h2 className="text-lg sm:text-xl font-semibold text-gray-800 truncate">
                  HTML Preview - {creative.name}
                </h2>
              </div>

              <Button
                variant="outline"
                size="sm"
                onClick={toggleHtmlPreviewFullscreen}
                className="flex items-center gap-2 text-green-700 border-green-300 hover:bg-green-50 hover:text-green-800 transition-colors w-full sm:w-auto"
              >
                <Minimize2 className="h-4 w-4" />
                <span>Exit Fullscreen</span>
              </Button>
            </div>

            {/* Fullscreen Content - Full Width Preview */}
            <div className="flex-1 bg-gray-50 p-3 sm:p-6">
              <div className="w-full h-full bg-white rounded-lg shadow-sm border border-gray-200">
                <iframe
                  srcDoc={
                    htmlContent ||
                    '<div style="display:flex;align-items:center;justify-content:center;height:100vh;font-family:Arial,sans-serif;color:#666;"><p>HTML content will appear here</p></div>'
                  }
                  title="HTML Preview - Fullscreen"
                  className="w-full h-full border-0 rounded-lg"
                  sandbox="allow-scripts allow-same-origin"
                />
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Fullscreen Image Preview Modal */}
      {isImagePreviewFullscreen &&
        isImage &&
        (creative.previewUrl || creative.url) && (
          <div className="fixed inset-0 bg-black bg-opacity-95 flex items-center justify-center z-[60] animate-in fade-in duration-200">
            <div className="relative w-full h-full flex items-center justify-center">
              {/* Exit Fullscreen Button */}
              <Button
                variant="outline"
                size="sm"
                onClick={toggleImagePreviewFullscreen}
                className="absolute top-3 sm:top-6 right-3 sm:right-6 flex items-center gap-2 text-white border-white/30 hover:bg-white/10 hover:text-white transition-colors z-10"
              >
                <Minimize2 className="h-4 w-4" />
                <span>Exit Fullscreen</span>
              </Button>

              {/* Header with filename */}
              <div className="absolute top-3 sm:top-6 left-3 sm:left-6 flex items-center gap-3 text-white z-10">
                <div className="p-2 bg-white/20 rounded-lg backdrop-blur-sm">
                  <Image className="h-4 w-4 sm:h-5 sm:w-5" />
                </div>
                <h2 className="text-sm sm:text-lg font-semibold truncate max-w-[200px] sm:max-w-none">
                  {creative.name}
                </h2>
              </div>

              {/* Fullscreen Image */}
              <div onClick={(e) => e.stopPropagation()}>
                <ImagePreview
                  src={creative.previewUrl || creative.url}
                  alt={creative.name}
                  fileName={creative.name}
                  className="max-w-[90vw] max-h-[80vh] object-contain rounded-lg shadow-2xl"
                />
              </div>

              {/* Click outside to close */}
              <div
                className="absolute inset-0 cursor-pointer"
                onClick={toggleImagePreviewFullscreen}
              />
            </div>
          </div>
        )}
    </div>
  );
};

export default SingleCreativeView;



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\ui\button.tsx
================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary-400 text-white shadow-xs hover:bg-primary-500 cursor-pointer",
        destructive:
          "bg-red-500 text-white shadow-xs hover:bg-red-500/90 cursor-pointer",
        outline:
          "border border-primary-400 text-primary-400 shadow-xs hover:bg-primary-400/10 cursor-pointer",
        secondary:
          "bg-secondary text-white shadow-xs hover:bg-secondary/80 cursor-pointer",
        ghost:
          "hover:bg-primary-400 hover:text-white cursor-pointer",
        link: "text-primary underline-offset-4 hover:underline cursor-pointer",
      },
      size: {
        default: "h-12 px-4 py-2",
        xs: "h-8 px-2 py-1",
        sm: "h-10 rounded-md gap-1.5 px-3",
        lg: "h-14 rounded-md px-6",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\ui\card.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\ui\ImagePreview.tsx
================================================================================

"use client";

import * as React from "react";
import { Image as ImageIcon } from "lucide-react";

type Props = {
  src: string;
  alt: string;
  fileName?: string;
  className?: string;
  onLoad?: () => void;
  onError?: () => void;
};

export function ImagePreview({
  src,
  alt,
  fileName = "",
  className = "w-full h-auto object-contain rounded-lg shadow-sm",
  onLoad,
  onError,
}: Props) {
  const [isLoading, setIsLoading] = React.useState(true);
  const [errored, setErrored] = React.useState(false);

  React.useEffect(() => {
    setIsLoading(true);
    setErrored(false);
  }, [src]);

  return (
    <div className="relative bg-gray-50">
      {!errored && (
        <img
          src={src}
          alt={alt}
          className={`${className} transition-opacity duration-300 ${isLoading ? "opacity-0" : "opacity-100"}`}
          crossOrigin="anonymous"
          onLoad={() => {
            setIsLoading(false);
            onLoad?.();
          }}
          onError={(e) => {
            console.error("Failed to load image:", src, "for file:", fileName, e);
            setErrored(true);
            setIsLoading(false);
            onError?.();
          }}
        />
      )}

      {isLoading && !errored && (
        <div className="absolute inset-0 flex items-center justify-center bg-gradient-to-br from-gray-50 to-gray-100">
          <div className="text-center">
            <ImageIcon className="h-10 w-10 text-gray-400 mx-auto mb-2" />
            <p className="text-xs font-medium text-gray-500">Loadingâ€¦</p>
          </div>
        </div>
      )}

      {errored && (
        <div className="flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-50 rounded-lg p-6">
          <div className="text-center">
            <ImageIcon className="h-10 w-10 text-blue-500 mx-auto mb-2" />
            <p className="text-xs font-medium text-blue-600">Image</p>
            <p className="text-xs text-blue-500 mt-1">{fileName.split(".").pop()?.toUpperCase()}</p>
            <p className="text-xs text-gray-400 mt-1">Failed to load</p>
          </div>
        </div>
      )}
    </div>
  );
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\ui\input.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "placeholder:text-color-muted-foreground selection:bg-color-primary selection:text-color-primary-foreground border-color-border flex h-12 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-blue-400 focus-visible:ring-blue-400/50 focus-visible:ring-[2px] focus-visible:ring-offset-0",
        "aria-invalid:ring-color-destructive/20 aria-invalid:border-color-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\ui\label.tsx
================================================================================

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\ui\select.tsx
================================================================================

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
              className={cn(
          "border-color-border data-[placeholder]:text-color-muted-foreground [&_svg:not([class*='text-'])]:text-color-muted-foreground focus-visible:border-blue-400 focus-visible:ring-blue-400/50 aria-invalid:ring-color-destructive/20 aria-invalid:border-color-destructive bg-transparent hover:bg-color-muted/30 flex w-fit items-center justify-between gap-2 rounded-md border px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-2 focus-visible:ring-blue-400 focus-visible:ring-offset-0 disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-12 data-[size=sm]:h-10 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
          className
        )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 text-color-muted-foreground" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-white text-color-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border border-color-border shadow-lg",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-color-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
              className={cn(
          "bg-white hover:bg-blue-50 hover:text-blue-700 focus:bg-blue-100 focus:text-blue-800 [&_svg:not([class*='text-'])]:text-color-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-3 pr-8 pl-3 text-base outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2 transition-colors duration-150",
          className
        )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-color-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\ui\separator.tsx
================================================================================

"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\components\ui\textarea.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "placeholder:text-color-muted-foreground selection:bg-color-primary selection:text-color-primary-foreground border-color-border flex w-full min-w-0 rounded-md border bg-transparent px-3 py-3 text-base shadow-xs transition-[color,box-shadow] outline-none disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm min-h-[100px]",
        "focus-visible:border-blue-400 focus-visible:ring-blue-400/50 focus-visible:ring-[2px] focus-visible:ring-offset-0",
        "aria-invalid:ring-color-destructive/20 aria-invalid:border-color-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\constants\fileUpload.ts
================================================================================

// File upload configuration interface
interface FileUploadConfigItem {
  ALLOWED_TYPES: string[]
  MAX_SIZE_MB: number
  ACCEPT_EXTENSIONS: string
  LABEL: string
  DESCRIPTION: string
  PLACEHOLDER: string
  REQUIREMENTS: string[]
}

// File upload configurations
export const FILE_UPLOAD_CONFIG: Record<string, FileUploadConfigItem> = {
  SINGLE_CREATIVE: {
    ALLOWED_TYPES: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'text/html', 'application/zip'],
    MAX_SIZE_MB: Infinity,
    ACCEPT_EXTENSIONS: '.jpg,.jpeg,.png,.gif,.webp,.html,.zip',
    LABEL: 'Single Creative',
    DESCRIPTION: 'Upload a single creative file or ZIP with assets',
    PLACEHOLDER: 'Drop your creative file here or click to browse',
    REQUIREMENTS: [
      'For HTML creatives: ZIP files with assets are automatically detected',
      'Single HTML files with images should be packaged as ZIP'
    ]
  },
  MULTIPLE_CREATIVES: {
    ALLOWED_TYPES: ['application/zip'],
    MAX_SIZE_MB: Infinity,
    ACCEPT_EXTENSIONS: '.zip',
    LABEL: 'Multiple Creatives',
    DESCRIPTION: 'Upload multiple creatives in a ZIP file',
    PLACEHOLDER: 'Drop your ZIP file here or click to browse',
    REQUIREMENTS: [
      'Supported formats: JPEG, PNG, GIF, WebP, HTML',
      'All files will be extracted and processed'
    ]
  }
}

// Upload status messages
export const UPLOAD_STATUS_MESSAGES = {
  IDLE: {
    SINGLE: 'Drop your creative file here or click to browse',
    MULTIPLE: 'Drop your ZIP file here or click to browse'
  },
  UPLOADING: {
    SINGLE: 'Uploading...',
    MULTIPLE: 'Processing ZIP...'
  },
  SUCCESS: {
    SINGLE: 'Creative uploaded successfully!',
    MULTIPLE: 'Multiple creatives uploaded successfully!'
  },
  ERROR: {
    SINGLE: 'Upload failed. Please try again.',
    MULTIPLE: 'Upload failed. Please try again.'
  }
}

// File type icons
export const FILE_TYPE_ICONS = {
  IMAGE: 'ðŸ–¼ï¸',
  HTML: 'ðŸŒ',
  ZIP: 'ðŸ“¦',
  UNKNOWN: 'ðŸ“„'
}

// File size formatting
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes'
  
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

// File type detection
export const getFileType = (fileName: string): string => {
  const extension = fileName.split('.').pop()?.toLowerCase()
  
  switch (extension) {
    case 'jpg':
    case 'jpeg':
    case 'png':
    case 'gif':
    case 'webp':
      return 'image'
    case 'html':
    case 'htm':
      return 'html'
    case 'zip':
      return 'zip'
    default:
      return 'unknown'
  }
}

// File validation rules
export const FILE_VALIDATION_RULES = {
  IMAGE: {
    MAX_DIMENSIONS: { width: 4096, height: 4096 },
    MIN_DIMENSIONS: { width: 100, height: 100 },
    ALLOWED_FORMATS: ['jpg', 'jpeg', 'png', 'gif', 'webp']
  },
  HTML: {
    MAX_SIZE_KB: 500,
    ALLOWED_TAGS: ['div', 'span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'img', 'a', 'button']
  },
  ZIP: {
    MAX_FILES: 100,
    MAX_DEPTH: 5,
    ALLOWED_CONTENT: ['image', 'html']
  }
}

// Single Creative View Constants
export const SINGLE_CREATIVE_VIEW_CONFIG = {
  MODAL: {
    MAX_WIDTH: 'max-w-7xl',
    HEIGHT: 'h-[90vh]',
    HEADER_HEIGHT: 'p-6',
    COLUMN_WIDTHS: {
      PREVIEW: 'flex-1',
      FEATURES: 'w-80',
      DETAILS: 'w-80'
    }
  },
  PREVIEW: {
    MIN_HEIGHT: 'min-h-[400px]',
    BACKGROUND: 'bg-gray-50',
    BORDER_RADIUS: 'rounded-lg'
  },
  FEATURES: {
    SPACING: 'space-y-4',
    CARD_PADDING: 'p-3',
    CARD_BORDER_RADIUS: 'rounded-lg'
  },
  ACTIONS: {
    BUTTON_VARIANTS: {
      PRIMARY: 'outline',
      SECONDARY: 'ghost',
      DANGER: 'ghost'
    },
    BUTTON_SIZES: {
      SMALL: 'sm',
      MEDIUM: 'default'
    }
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\constants\index.ts
================================================================================

// Export all constants
export * from './fileUpload'

// Telegram Bot Configuration
export const TELEGRAM_BOT_URL = 'https://t.me/BigDropsMarketingBot?start=from_web_form'



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\hooks\index.ts
================================================================================

// Export all custom hooks
export * from './useFileUpload'



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\hooks\useFileUpload.ts
================================================================================

import { useState, useCallback } from 'react'

export interface FileUploadState {
  selectedFile: File | null
  uploadStatus: 'idle' | 'uploading' | 'success' | 'error'
  errorMessage: string
  dragActive: boolean
}

export interface FileUploadHandlers {
  handleDrag: (e: React.DragEvent) => void
  handleDrop: (e: React.DragEvent) => void
  handleFileSelect: (file: File) => void
  handleFileInput: (e: React.ChangeEvent<HTMLInputElement>) => void
  resetState: () => void
}

export const useFileUpload = (
  allowedTypes: string[],
  maxSizeMB: number,
  onFileUpload: (file: File) => void | Promise<void>
) => {
  const [state, setState] = useState<FileUploadState>({
    selectedFile: null,
    uploadStatus: 'idle',
    errorMessage: '',
    dragActive: false
  })

  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    if (e.type === "dragenter" || e.type === "dragover") {
      setState(prev => ({ ...prev, dragActive: true }))
    } else if (e.type === "dragleave") {
      setState(prev => ({ ...prev, dragActive: false }))
    }
  }, [])

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    setState(prev => ({ ...prev, dragActive: false }))

    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      const file = e.dataTransfer.files[0]
      handleFileSelect(file)
    }
  }, [])

  const handleFileSelect = useCallback(async (file: File) => {
    const isValidType = allowedTypes.includes(file.type) || 
                       allowedTypes.some(type => file.name.endsWith(type)) ||
                       (file.name.toLowerCase().endsWith('.zip') && (
                         file.type === 'application/zip' ||
                         file.type === 'application/x-zip' ||
                         file.type === 'application/x-zip-compressed' ||
                         file.type === 'multipart/x-zip' ||
                         file.type === 'application/octet-stream' ||
                         file.type === ''
                       ));
    
    if (!isValidType) {
      setState(prev => ({
        ...prev,
        errorMessage: `Please select a valid file type: ${allowedTypes.join(', ')}`
      }))
      return
    }

    // Validate file size (skip if maxSizeMB is Infinity)
    if (maxSizeMB !== Infinity && file.size > maxSizeMB * 1024 * 1024) {
      setState(prev => ({
        ...prev,
        errorMessage: `File size must be less than ${maxSizeMB}MB`
      }))
      return
    }

    // Auto-start upload immediately after selection
    setState(prev => ({
      ...prev,
      selectedFile: file,
      uploadStatus: 'uploading',
      errorMessage: ''
    }))

    try {
      await Promise.resolve(onFileUpload(file))
      setState(prev => ({ ...prev, uploadStatus: 'success' }))
    } catch (e) {
      setState(prev => ({
        ...prev,
        uploadStatus: 'error',
        errorMessage: 'Upload failed. Please try again.'
      }))
    }
  }, [allowedTypes, maxSizeMB, onFileUpload])

  const handleFileInput = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      handleFileSelect(e.target.files[0])
    }
  }, [handleFileSelect])

  const resetState = useCallback(() => {
    setState({
      selectedFile: null,
      uploadStatus: 'idle',
      errorMessage: '',
      dragActive: false
    })
  }, [])

  const startUpload = useCallback(async () => {
    // Kept for backward compatibility but upload now triggers on selection
    if (!state.selectedFile) return
    try {
      onFileUpload(state.selectedFile)
      setState(prev => ({ ...prev, uploadStatus: 'success' }))
      resetState()
    } catch (error) {
      setState(prev => ({ 
        ...prev, 
        uploadStatus: 'error',
        errorMessage: 'Upload failed. Please try again.'
      }))
    }
  }, [state.selectedFile, onFileUpload, resetState])

  return {
    state,
    handlers: {
      handleDrag,
      handleDrop,
      handleFileSelect,
      handleFileInput,
      resetState
    },
    startUpload
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\assetRewriter.ts
================================================================================

import { JSDOM } from "jsdom";

export function isAbsoluteUrl(u: string) {
  return /^(https?:)?\/\//i.test(u) || /^(data:|blob:|mailto:|tel:)/i.test(u);
}

export function joinUrl(base: string, rel: string) {
  try {
    return new URL(rel, base).toString();
  } catch {
    if (base.endsWith("/") && rel.startsWith("/")) return base + rel.slice(1);
    if (!base.endsWith("/") && !rel.startsWith("/")) return `${base}/${rel}`;
    return base + rel;
  }
}

export function rewriteHtmlAssets(html: string, baseUrl: string) {
  const dom = new JSDOM(html);
  const { document } = dom.window;

  const rewriteAttr = (selector: string, attr: "src" | "href") => {
    document.querySelectorAll(selector).forEach((el) => {
      const v = el.getAttribute(attr);
      if (!v || isAbsoluteUrl(v) || v.startsWith("#")) return;
      el.setAttribute(attr, joinUrl(baseUrl, v));
    });
  };

  rewriteAttr("img[src]", "src");
  rewriteAttr("script[src]", "src");
  rewriteAttr("link[href]", "href");

  document.querySelectorAll<HTMLElement>("[style]").forEach((el) => {
    const style = el.getAttribute("style");
    if (!style) return;
    el.setAttribute("style", rewriteCssUrls(style, baseUrl));
  });

  document.querySelectorAll("style").forEach((styleEl) => {
    const css = styleEl.textContent || "";
    styleEl.textContent = rewriteCssUrls(css, baseUrl);
  });

  return dom.serialize();
}

export function rewriteCssUrls(css: string, baseUrl: string) {
  return css.replace(
    /url\(\s*(?:'([^']+)'|"([^"]+)"|([^'")]+))\s*\)/gi,
    (_m, s1, s2, s3) => {
      const raw = s1 || s2 || s3 || "";
      const trimmed = raw.trim();
      if (!trimmed || isAbsoluteUrl(trimmed) || trimmed.startsWith("#")) {
        return `url(${raw})`;
      }
      return `url(${joinUrl(baseUrl, trimmed)})`;
    }
  );
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\conversion.ts
================================================================================

export async function maybeConvert(buffer: Buffer, mime: string): Promise<{ buffer: Buffer; mime: string; ext: string | null }> {
  if (process.env.ENABLE_IMAGE_CONVERSION === '1' && mime === 'image/webp') {
    try {
      const sharp = await import('sharp');
      const out = await sharp.default(buffer).jpeg({ quality: 80 }).toBuffer();
      return { buffer: out, mime: 'image/jpeg', ext: 'jpg' };
    } catch {
      
    }
  }
  return { buffer, mime, ext: null };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\creativeClient.ts
================================================================================

export async function saveCreative(body: Record<string, unknown>) {
  const r = await fetch("/api/creative/save", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  if (!r.ok) throw new Error("Save failed");
  return r.json();
}

export async function deleteCreativeApi(arg: { fileUrl?: string; creativeId?: string }) {
  const r = await fetch("/api/creative/delete", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(arg),
  });
  if (!r.ok) throw new Error("Delete failed");
  return r.json();
}

export async function saveHtml(arg: { fileUrl: string; html: string; newFileName?: string }) {
  const r = await fetch("/api/creative/save-html", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(arg),
  });
  if (!r.ok) throw new Error("Save HTML failed");
  return r.json();
}

export async function renameCreative(arg: { creativeId?: string; fileUrl?: string; newName: string }) {
  const r = await fetch("/api/creative/rename", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(arg),
  });
  if (!r.ok) throw new Error("Rename failed");
  return r.json();
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\db.ts
================================================================================

import { Pool } from "pg";

declare global {
  // allow global var in dev hot-reload
  var __pgPool__: Pool | undefined;
}

export function getPool(): Pool {
  const exists = globalThis.__pgPool__;
  if (exists) return exists;

  const url = process.env.DATABASE_URL;
  if (!url) throw new Error("DATABASE_URL env var is required");

  const pool = new Pool({
    connectionString: url,
    ssl: { rejectUnauthorized: false },
    max: 3,
    idleTimeoutMillis: 10000,
    connectionTimeoutMillis: 5000,
  });

  globalThis.__pgPool__ = pool;
  return pool;
}

async function init() {
  const pool = getPool();
  
  await pool.query(`
    CREATE TABLE IF NOT EXISTS telegram_users (
      id SERIAL PRIMARY KEY,
      username VARCHAR(255) UNIQUE NOT NULL,
      chat_id BIGINT NOT NULL,
      first_name VARCHAR(255),
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    );
  `);
  
  await pool.query(`
    CREATE TABLE IF NOT EXISTS creatives (
      id UUID PRIMARY KEY,
      affiliate_id TEXT,
      company_name TEXT,
      first_name TEXT,
      last_name TEXT,
      email TEXT,
      telegram_id TEXT,
      offer_id TEXT,
      creative_type TEXT,
      from_lines TEXT,
      subject_lines TEXT,
      notes TEXT,
      priority TEXT,
      created_at TIMESTAMP DEFAULT NOW()
    );
  `);
  
  await pool.query(`
    CREATE TABLE IF NOT EXISTS creative_files (
      id UUID PRIMARY KEY,
      creative_id UUID REFERENCES creatives(id) ON DELETE CASCADE,
      file_name TEXT,
      file_url TEXT,
      file_type TEXT,
      file_size BIGINT
    );
  `);
  
  await pool.query(`
    CREATE TABLE IF NOT EXISTS telegram_state (
      key TEXT PRIMARY KEY,
      value TEXT,
      updated_at TIMESTAMP DEFAULT NOW()
    )
  `);
  
  await pool.query(`
    CREATE TABLE IF NOT EXISTS submissions (
      id SERIAL PRIMARY KEY,
      offer_id TEXT NOT NULL,
      priority TEXT,
      contact_method TEXT,
      contact_info TEXT NOT NULL,
      from_lines TEXT,
      subject_lines TEXT,
      other_request TEXT,
      created_at TIMESTAMP DEFAULT NOW()
    );
  `);
  
  await pool.query(`
    CREATE TABLE IF NOT EXISTS submission_files (
      id SERIAL PRIMARY KEY,
      submission_id INTEGER REFERENCES submissions(id) ON DELETE CASCADE,
      file_url TEXT,
      file_key TEXT,
      original_filename TEXT,
      creative_from_lines TEXT,
      creative_subject_lines TEXT,
      creative_notes TEXT,
      creative_html_code TEXT,
      created_at TIMESTAMP DEFAULT NOW()
    );
  `);
}

init().catch((error) => {
  console.error("Failed to initialize database tables:", error);
});




================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\emailService.ts
================================================================================

import * as nodemailer from 'nodemailer';

let transporter: nodemailer.Transporter | null = null;

function getTransporter() {
  if (!transporter) {
    if (!process.env.SMTP_HOST || !process.env.SMTP_PORT || !process.env.SMTP_USER || !process.env.SMTP_PASS) {
      throw new Error('SMTP env vars missing (SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS)');
    }
    
    transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: parseInt(process.env.SMTP_PORT as string, 10),
      secure: false,
      auth: { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS },
    });
  }
  return transporter;
}

export const createSubmissionEmail = (data: { contactName: string; priority: string; trackingLink: string; }) => `
<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><style>
body{font-family:Arial,sans-serif;line-height:1.6;color:#333}.container{max-width:600px;margin:0 auto;padding:20px}.header{background:#3b82f6;color:#fff;padding:20px;text-align:center}.content{padding:20px;background:#f9fafb}.tracking-link{background:#e0e7ff;padding:15px;border-radius:8px;margin:20px 0}.footer{text-align:center;padding:20px;color:#6b7280;font-size:14px}
</style></head><body><div class="container"><div class="header"><h1>Submission Confirmed!</h1></div><div class="content">
<p>Hello ${data.contactName},</p><p>Thank you for your submission! We have received your creative.</p>
<p><strong>Priority:</strong> ${data.priority}</p>
<div class="tracking-link"><strong>Your Tracking Link:</strong><br><a href="${data.trackingLink}" style="color:#3b82f6">${data.trackingLink}</a></div>
<p>You can use this link to track your submission.</p><p>Best,<br>Big Drops Marketing Team</p></div>
<div class="footer"><p>This is an automated message. Please do not reply.</p></div></div></body></html>
`;

export async function sendEmail(opts: { to: string; subject: string; html: string }) {
  const emailTransporter = getTransporter();
  const info = await emailTransporter.sendMail({
    from: `"Big Drops Marketing" <${process.env.SMTP_USER}>`,
    to: opts.to, subject: opts.subject, html: opts.html
  });
  return { success: true, messageId: info.messageId };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\everflow.ts
================================================================================

const BASE = process.env.EVERFLOW_BASE_URL || 'https://api.eflow.team/v1';
const KEY = process.env.EVERFLOW_API_KEY || '';

export async function fetchOffers(search?: string) {
  if (!KEY) {

    return [];
  }
  const url = new URL(`${BASE}/offers`);
  if (search) url.searchParams.set('search', search);
  const res = await fetch(url.toString(), { headers: { Authorization: `Bearer ${KEY}` }});
  if (!res.ok) throw new Error(`Everflow error ${res.status}`);
  const data = await res.json();

  return (data.items || data).map((o: { offer_id?: string; id?: string; name: string }) => ({ 
    label: `${o.offer_id || o.id} â€” ${o.name}`, 
    value: String(o.offer_id || o.id) 
  }));
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\filesClient.ts
================================================================================

export async function deleteFileById(id: string) {
  const r = await fetch(`/api/files/${encodeURIComponent(id)}`, { method: 'DELETE' });
  if (!r.ok) throw new Error('delete failed');
  return r.json();
}

export async function bulkDeleteByIds(ids: string[]) {
  const r = await fetch('/api/files/bulk-delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ ids }),
  });
  if (!r.ok) throw new Error('bulk delete failed');
  return r.json();
}

export function parseIdsFromUrl(u: string) {
  try {
    if (u.includes('/api/files/')) {
      const m = u.match(/\/api\/files\/([^/]+)\/([^?#]+)/);
      if (m) return { id: decodeURIComponent(m[1]), name: decodeURIComponent(m[2]) };
    }
    if (u.includes('/api/uploads')) {
      const url = new URL(u, 'http://x');
      const id = url.searchParams.get('id') || '';
      const name = url.searchParams.get('name') || '';
      if (id && name) return { id, name };
    }
  } catch {}
  return { id: '', name: '' };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\fileStorage.ts
================================================================================


import { randomUUID } from 'crypto';
import { promises as fs } from 'fs';
import * as path from 'path';

const ROOT = '/tmp/creatives';
async function ensureDir(dir: string) { await fs.mkdir(dir, { recursive: true }); }

export async function saveBuffer(buf: Buffer, originalName: string) {
  const id = randomUUID();
  const safeName = originalName.replace(/[^\w.\-]+/g, '_');
  const dir = path.join(ROOT, id);
  await ensureDir(dir);
  const full = path.join(dir, safeName);
  await fs.writeFile(full, buf);
  return { id, fileName: safeName };
}

export async function getFilePath(id: string, fileName: string) {
  return path.join(ROOT, id, fileName);
}


export function getFileDir(id: string) {
  return path.join(ROOT, id);
}

async function walkFiles(dir: string) {
  const out: { path: string; bytes: number }[] = [];
  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    for (const e of entries) {
      const p = path.join(dir, e.name);
      if (e.isDirectory()) {
        const child = await walkFiles(p);
        out.push(...child);
      } else if (e.isFile()) {
        const stat = await fs.stat(p);
        out.push({ path: p, bytes: stat.size });
      }
    }
  } catch {
    // ignore
  }
  return out;
}

export async function deleteFileTreeById(id: string) {
  const dir = getFileDir(id);
  const files = await walkFiles(dir);
  let bytes = 0;
  for (const f of files) bytes += f.bytes;

  // best-effort rm
  await fs.rm(dir, { recursive: true, force: true });

  return {
    filesDeleted: files.map(f => f.path),
    bytesReclaimed: bytes,
    dir,
  };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\generationClient.ts
================================================================================

export async function generateEmailContent(opts: {
  creativeType?: string;
  audience?: string;
  brandVoice?: string;
  industry?: string;
  campaignGoal?: string;
  notes?: string;
  sampleText?: string;
  maxFrom?: number;
  maxSubject?: number;
}) {
  const r = await fetch("/api/generate-email-content", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(opts),
  });
  if (!r.ok) {
    const err = await r.json().catch(() => ({}));
    throw new Error(err.error || `HTTP ${r.status}`);
  }
  return (await r.json()) as { fromLines: string[]; subjectLines: string[] };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\logging.ts
================================================================================

export async function sendToLoggingService(payload: Record<string, unknown>) {
  const url = process.env.LOG_WEBHOOK_URL;
  if (!url) { console.error('[log]', payload); return; }
  try {
    await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
  } catch (e) {
    console.error('[log-fail]', (e as Error).message, payload);
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\preview.ts
================================================================================

export async function makeImagePreview(buf: Buffer, width = 400) {
  try {
    const sharp = await import('sharp');
    const img = sharp.default(buf).resize({ width }).jpeg({ quality: 70 });
    return await img.toBuffer();
  } catch {
    return null; 
  }
}

export async function makeBasicTextPreview(buf: Buffer, max = 2048) {
  const s = buf.toString('utf8');
  return s.slice(0, max);
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\progressStore.ts
================================================================================

type ProgressState =
  | { status: 'queued' | 'running'; pct: number; note?: string; meta?: unknown }
  | { status: 'done'; pct: 100; result?: unknown; meta?: unknown }
  | { status: 'error'; pct: number; error: string; meta?: unknown };

const GLOBAL = globalThis as { __PROGRESS_KV__?: Map<string, { value: ProgressState; expiresAt: number }> };
if (!GLOBAL.__PROGRESS_KV__) GLOBAL.__PROGRESS_KV__ = new Map<string, { value: ProgressState; expiresAt: number }>();
const KV: Map<string, { value: ProgressState; expiresAt: number }> = GLOBAL.__PROGRESS_KV__;

const DEFAULT_TTL_MS = 30 * 60 * 1000; 

function now() { return Date.now(); }
function gc() {
  const t = now();
  for (const [k, v] of KV.entries()) if (v.expiresAt <= t) KV.delete(k);
}

export function progressStart(id: string, meta?: unknown, ttlMs = DEFAULT_TTL_MS) {
  gc();
  KV.set(id, { value: { status: 'queued', pct: 0, meta }, expiresAt: now() + ttlMs });
}

export function progressUpdate(id: string, pct: number, note?: string, metaPatch?: unknown, ttlMs = DEFAULT_TTL_MS) {
  const cur = KV.get(id)?.value;
  const mergedMeta = { ...(cur as { meta?: Record<string, unknown> })?.meta, ...(metaPatch as Record<string, unknown> || {}) };
  KV.set(id, {
    value: { status: 'running', pct: Math.max(0, Math.min(99, Math.round(pct))), note, meta: mergedMeta },
    expiresAt: now() + ttlMs
  });
}

export function progressDone(id: string, result?: unknown, ttlMs = DEFAULT_TTL_MS) {
  KV.set(id, { value: { status: 'done', pct: 100, result }, expiresAt: now() + ttlMs });
}

export function progressError(id: string, error: string, pct = 0, ttlMs = DEFAULT_TTL_MS) {
  KV.set(id, { value: { status: 'error', pct, error }, expiresAt: now() + ttlMs });
}

export function progressGet(id: string): ProgressState | null {
  gc();
  const v = KV.get(id);
  return v ? v.value : null;
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\proofreadClient.ts
================================================================================

import { ProofreadResult } from "@/types/proofread";

export async function proofreadTextClaude(text: string): Promise<ProofreadResult> {
  const res = await fetch("/api/proofread-text", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text }),
  });
  if (!res.ok) throw new Error("proofread-text failed");
  return res.json();
}

export async function proofreadImageGPT(imageUrl: string): Promise<ProofreadResult> {
  const res = await fetch("/api/proofread-image", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ imageUrl }),
  });
  if (!res.ok) throw new Error("proofread-image failed");
  return res.json();
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\proofreadCreativeClient.ts
================================================================================

export interface ProofreadCreativeRequest {
  creativeId?: string;
  creativeType?: "email"|"display"|"search"|"social"|"native"|"push";
  fileType: "image"|"html";
  fileUrl?: string;
  htmlContent?: string;
  offerId?: string;
  industry?: string;
  targetAudience?: string;
  campaignGoal?: string;
  brandVoice?: string;
}

export interface ProofreadCreativeResponse {
  success: boolean;
  issues: Array<{
    icon: string;
    type: string;
    original?: string;
    correction?: string;
    note?: string;
  }>;
  suggestions: Array<{
    icon: string;
    type: string;
    description: string;
  }>;
  qualityScore: {
    grammar: number;
    readability: number;
    conversion: number;
    brandAlignment: number;
  };
}

export async function proofreadCreative(request: ProofreadCreativeRequest): Promise<ProofreadCreativeResponse> {
  const response = await fetch('/api/proofread-creative', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.error || `HTTP ${response.status}`);
  }

  return response.json();
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\quarantine.ts
================================================================================

import { saveBuffer } from '@/lib/fileStorage';

export async function quarantineBuffer(buf: Buffer, originalName: string, reason: string) {
  const safeName = `QUARANTINE_${Date.now()}_${reason.replace(/[^a-z0-9_-]+/gi,'-')}_${originalName}`;
  const { id, fileName } = await saveBuffer(buf, safeName);
  return { id, fileName };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\rateLimit.ts
================================================================================

type Bucket = { tokens: number; last: number };
const globalAny = globalThis as { __RL__?: Map<string, Bucket> };
if (!globalAny.__RL__) globalAny.__RL__ = new Map<string, Bucket>();
const RL: Map<string, Bucket> = globalAny.__RL__;

export function rateLimit(key: string, opts = { capacity: 10, refillPerSec: 1 }): boolean {
  const now = Date.now();
  const b = RL.get(key) || { tokens: opts.capacity, last: now };
  const elapsed = (now - b.last) / 1000;
  b.tokens = Math.min(opts.capacity, b.tokens + elapsed * opts.refillPerSec);
  b.last = now;
  if (b.tokens < 1) { RL.set(key, b); return false; }
  b.tokens -= 1; RL.set(key, b);
  return true;
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\security\checksums.ts
================================================================================

import crypto from 'crypto';

export function sha256(buf: Buffer): string {
  return crypto.createHash('sha256').update(buf).digest('hex');
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\security\clamav.ts
================================================================================

import net from 'net';
export type ClamVerdict = 'OK' | `FOUND:${string}` | 'UNAVAILABLE';

function writeChunk(socket: net.Socket, chunk: Buffer) {
  const len = Buffer.alloc(4);
  len.writeUInt32BE(chunk.length);
  socket.write(len);
  socket.write(chunk);
}
export async function scanBufferWithClamAV(buffer: Buffer, opts?: { host?: string; port?: number; timeoutMs?: number }): Promise<ClamVerdict> {
  const host = opts?.host ?? process.env.CLAMAV_HOST ?? '127.0.0.1';
  const port = Number(opts?.port ?? process.env.CLAMAV_PORT ?? 3310);
  const timeoutMs = opts?.timeoutMs ?? 15000;

  return new Promise((resolve) => {
    const socket = new net.Socket();
    let data = '';
    let ended = false;
    const end = (v: ClamVerdict) => { if (ended) return; ended = true; try { socket.destroy(); } catch {} resolve(v); };
    socket.setTimeout(timeoutMs, () => end('UNAVAILABLE'));
    socket.connect(port, host, () => {
      socket.write('zINSTREAM\0');
      const CHUNK = 64 * 1024;
      for (let i = 0; i < buffer.length; i += CHUNK) {
        writeChunk(socket, buffer.subarray(i, Math.min(i + CHUNK, buffer.length)));
      }
      socket.write(Buffer.from([0, 0, 0, 0])); // end
    });
    socket.on('data', (b) => (data += b.toString('utf8')));
    socket.on('error', () => end('UNAVAILABLE'));
    socket.on('close', () => {
      const line = data.trim();
      if (!line) return end('UNAVAILABLE');
      if (line.endsWith('OK')) return end('OK');
      const m = line.match(/\b(.+?)\s+FOUND$/);
      if (m) return end(`FOUND:${m[1]}` as ClamVerdict);
      return end('UNAVAILABLE');
    });
  });
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\security\fileType.ts
================================================================================

import type { FileTypeResult } from 'file-type';

let fileType: { fileTypeFromBuffer?: (buffer: Buffer) => Promise<FileTypeResult | undefined> } | null = null;
try {
  fileType = await import('file-type');
} catch {}

export type DetectedType = { mime: string; ext: string | null };

function fallbackDetect(buf: Buffer, name?: string): DetectedType | null {
  if (buf.length >= 8 && buf.toString('hex', 0, 8) === '89504e470d0a1a0a')
    return { mime: 'image/png', ext: 'png' };
  if (buf.length >= 3 && buf[0] === 0xff && buf[1] === 0xd8 && buf[2] === 0xff)
    return { mime: 'image/jpeg', ext: 'jpg' };
  if (buf.length >= 6 && (buf.slice(0, 6).toString() === 'GIF87a' || buf.slice(0, 6).toString() === 'GIF89a'))
    return { mime: 'image/gif', ext: 'gif' };
  if (buf.length >= 4 && buf.slice(0, 4).toString() === '%PDF')
    return { mime: 'application/pdf', ext: 'pdf' };
  if (buf.length >= 4 && buf[0] === 0x50 && buf[1] === 0x4b && (buf[2] === 0x03 || buf[2] === 0x05 || buf[2] === 0x07))
    return { mime: 'application/zip', ext: 'zip' };
  const str = buf.slice(0, 512).toString('utf8').trim().toLowerCase();
  if (str.startsWith('<svg '))
    return { mime: 'image/svg+xml', ext: 'svg' };
  if (str.startsWith('<!doctype html') || str.startsWith('<html') || (name && /\.html?$/i.test(name)))
    return { mime: 'text/html', ext: name?.match(/\.html?$/i) ? name.split('.').pop()!.toLowerCase() : 'html' };
  return null;
}

export async function detectFileType(buffer: Buffer, originalName?: string): Promise<DetectedType> {
  let res: FileTypeResult | undefined;
  if (fileType?.fileTypeFromBuffer) {
    try { res = await fileType.fileTypeFromBuffer(buffer); } catch {}
  }
  if (res?.mime) return { mime: res.mime, ext: res.ext ?? null };
  const fb = fallbackDetect(buffer, originalName ?? undefined);
  if (fb) return fb;
  return { mime: 'application/octet-stream', ext: null };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\uploadClient.ts
================================================================================

export type UploadOpts = {
  endpoint: string;
  headers?: Record<string,string>;
  onProgress?: (pct:number)=>void;
  retry?: { retries:number; baseDelayMs:number };
  chunking?: { enabled:boolean; chunkSize:number };
  compressImages?: boolean;
  metadata?: Record<string, unknown>;
};

async function sleep(ms:number){ return new Promise(r=>setTimeout(r,ms)); }

async function maybeCompress(file: File, compress: boolean): Promise<File> {
  if (!compress || !file.type.startsWith('image/')) return file;
  const mod = await import('browser-image-compression');
  const blob = await mod.default(file, { maxSizeMB: 1.5, maxWidthOrHeight: 2000, useWebWorker: true });
  return new File([blob], file.name, { type: file.type });
}

function xhrUpload(url:string, file:Blob, headers:Record<string,string>, onProgress?: (n:number)=>void) {
  return new Promise<Response>((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', url, true);
    for (const [k,v] of Object.entries(headers||{})) xhr.setRequestHeader(k, v);
    xhr.upload.onprogress = (e) => {
      if (e.lengthComputable && onProgress) onProgress(Math.round((e.loaded/e.total)*100));
    };
    xhr.onload = () => resolve(new Response(xhr.responseText, { status: xhr.status }));
    xhr.onerror = () => reject(new Error('Network error'));
    const fd = new FormData();
    fd.append('file', file);
    xhr.send(fd);
  });
}

export async function uploadFile(file: File, opts: UploadOpts) {
  const {
    endpoint, headers={}, onProgress, retry={retries:0, baseDelayMs:300},
    compressImages=false, metadata
  } = opts;

  const prepared = await maybeCompress(file, compressImages);

  let attempt = 0;
  while (true) {
    try {
      const uploadUrl = endpoint; 
      const res = await xhrUpload(uploadUrl, prepared, { ...headers, ...(metadata ? {'X-Meta': JSON.stringify(metadata)} : {}) }, onProgress);
      if (!res.ok) throw new Error(`Upload failed (${res.status}) ${await res.text()}`);
      return await res.json().catch(()=> ({}));
    } catch (e) {
      if (attempt >= retry.retries) throw e as Error;
      attempt++;
      await sleep(retry.baseDelayMs * Math.pow(2, attempt-1));
    }
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\utils.ts
================================================================================

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\zip.ts
================================================================================

import JSZip from 'jszip';
import { detectFileType } from '@/lib/security/fileType';
import { scanBufferWithClamAV } from '@/lib/security/clamav';
import { sha256 } from '@/lib/security/checksums';
import { saveBuffer } from '@/lib/fileStorage';
import { makeImagePreview } from '@/lib/preview';

export type ZipProcessOptions = {
  allow: Set<string>;
  maxFiles: number;
  maxTotalBytes: number;
  maxDepth: number;
  perFileMaxBytes?: number;
  enableVirusScan?: boolean;
  deduplicate?: boolean;

  onEntry?: (info: { path: string; index: number; total: number }) => void;
  onProgress?: (pct: number) => void; 
};

export async function processZipBuffer(zipBuf: Buffer, opts: ZipProcessOptions, depth = 0, seenHashes?: Set<string>) {
  if (depth > opts.maxDepth) return { extracted: [], totalBytes: 0, skipped: [{ reason: 'depth-limit' }] };

  const zip = await JSZip.loadAsync(zipBuf).catch(() => null);
  if (!zip) return { extracted: [], totalBytes: 0, skipped: [{ reason: 'corrupted-zip' }] };

  const extracted: Array<{
    fileId: string;
    fileName: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    hash: string;
    depth: number;
    previewUrl?: string;
  }> = [];
  const skipped: Array<{
    path?: string;
    reason: string;
  }> = [];
  let totalBytes = 0;
  let count = 0;
  const dedupSet = seenHashes ?? new Set<string>();

  const entries = Object.entries(zip.files);
  const totalCount = Math.min(entries.length, opts.maxFiles);
  let processed = 0;

  for (const [path, entry] of entries) {
    if ((entry as JSZip.JSZipObject).dir) continue;
    count++;
    processed++;
    
    opts.onEntry?.({ path, index: processed, total: totalCount });
    if (opts.onProgress) {
      const pct = Math.round((processed / totalCount) * 90); 
      opts.onProgress(pct);
    }
    
    if (count > opts.maxFiles) { skipped.push({ path, reason: 'file-count-limit' }); break; }
    if (path.includes('..')) { skipped.push({ path, reason: 'path-traversal' }); continue; }

    let buf: Buffer;
    try { buf = await (entry as JSZip.JSZipObject).async('nodebuffer'); }
    catch { skipped.push({ path, reason: 'extract-failed' }); continue; }

    totalBytes += buf.length;
    if (totalBytes > opts.maxTotalBytes) { skipped.push({ path, reason: 'total-size-limit' }); break; }
    if (opts.perFileMaxBytes && buf.length > opts.perFileMaxBytes) { skipped.push({ path, reason: 'per-file-size-limit' }); continue; }

    const { mime } = await detectFileType(buf, path);

    if (mime === 'application/zip') {
      const nested = await processZipBuffer(buf, opts, depth + 1, dedupSet);
      extracted.push(...nested.extracted);
      skipped.push(...nested.skipped);
      totalBytes += nested.totalBytes;
      continue;
    }

    if (!opts.allow.has(mime)) { skipped.push({ path, reason: `disallowed-mime:${mime}` }); continue; }

    if (opts.enableVirusScan) {
      const verdict = await scanBufferWithClamAV(buf);
      if (verdict !== 'OK') { skipped.push({ path, reason: `virus:${verdict}` }); continue; }
    }

    const hash = sha256(buf);
    if (opts.deduplicate && dedupSet.has(hash)) { skipped.push({ path, reason: 'duplicate' }); continue; }
    dedupSet.add(hash);

    const baseName = path.split('/').pop() || 'file';
    const { id, fileName } = await saveBuffer(buf, baseName);

    let previewUrl: string | undefined;
    if (mime.startsWith('image/') && mime !== 'image/svg+xml') {
      const thumb = await makeImagePreview(buf, 400);
      if (thumb) {
        const prev = await saveBuffer(thumb, `preview_${fileName}.jpg`);
        previewUrl = `/api/files/${prev.id}/${prev.fileName}`;
      }
    }

    extracted.push({
      fileId: id,
      fileName,
      fileUrl: `/api/files/${id}/${fileName}`,
      fileSize: buf.length,
      fileType: mime,
      hash,
      depth,
      previewUrl
    });
  }

  opts.onProgress?.(95);

  return { extracted, totalBytes, skipped };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\zipPassword.ts
================================================================================

/* eslint-disable @typescript-eslint/no-explicit-any */

import { detectFileType } from '@/lib/security/fileType';
import { scanBufferWithClamAV } from '@/lib/security/clamav';
import { sha256 } from '@/lib/security/checksums';
import { saveBuffer } from '@/lib/fileStorage';

export type PwExtractOptions = {
  allow: Set<string>;
  enableVirusScan?: boolean;
  perFileMaxBytes?: number;
};

export async function extractEncryptedZipBuffer(zipBuf: Buffer, password: string, opts: PwExtractOptions) {
  let AdmZip: any = null;
  try {
    const admZipModule = await import('adm-zip');
    AdmZip = admZipModule.default || admZipModule;
  } catch {
    return { extracted: [], skipped: [{ reason: 'encrypted-zip-support-not-installed' }], usedLibrary: false };
  }

  if (!AdmZip) {
    return { extracted: [], skipped: [{ reason: 'encrypted-zip-support-not-installed' }], usedLibrary: false };
  }

  const zip = new AdmZip(zipBuf);
  zip.setPassword(password);

  const entries = zip.getEntries();
  const extracted: Array<{
    fileId: string;
    fileName: string;
    fileUrl: string;
    fileSize: number;
    fileType: string;
    hash: string;
    depth: number;
    encrypted: boolean;
  }> = [];
  const skipped: Array<{
    path?: string;
    reason: string;
  }> = [];

  for (const entry of entries) {
    const name: string = entry.entryName;
    if (entry.isDirectory) continue;
    if (name.includes('..')) { skipped.push({ path: name, reason: 'path-traversal' }); continue; }

    let data: Buffer;
    try {
      data = entry.getData();
    } catch {
      skipped.push({ path: name, reason: 'decrypt-failed' });
      continue;
    }

    if (opts.perFileMaxBytes && data.length > opts.perFileMaxBytes) {
      skipped.push({ path: name, reason: 'per-file-size-limit' });
      continue;
    }

    const { mime } = await detectFileType(data, name);
    if (!opts.allow.has(mime)) { skipped.push({ path: name, reason: `disallowed-mime:${mime}` }); continue; }

    if (opts.enableVirusScan) {
      const verdict = await scanBufferWithClamAV(data);
      if (verdict !== 'OK') { skipped.push({ path: name, reason: `virus:${verdict}` }); continue; }
    }

    const { id, fileName } = await saveBuffer(data, name.split('/').pop() || 'file');
    extracted.push({
      fileId: id,
      fileName,
      fileUrl: `/api/files/${id}/${fileName}`,
      fileSize: data.length,
      fileType: mime,
      hash: sha256(data),
      depth: 0,
      encrypted: true,
    });
  }

  return { extracted, skipped, usedLibrary: true };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\lib\zipPreview.ts
================================================================================



type Entry = {
  name: string;
  compressedSize: number;
  uncompressedSize: number;
  method: number;              
  encrypted: boolean;
  isDirectory: boolean;
  compressionRatio: number | null; 
};

type Preview = {
  entries: Entry[];
  totals: {
    files: number;
    dirs: number;
    compressed: number;
    uncompressed: number;
    overallRatio: number | null; 
  };
  suspicious: {
    highExpansionEntries: { name: string; ratio: number; uncompressedSize: number; compressedSize: number }[];
    highOverallExpansion: boolean;
  };
};

function readU16(buf: Buffer, off: number) { return buf.readUInt16LE(off); }
function readU32(buf: Buffer, off: number) { return buf.readUInt32LE(off); }

function findEOCD(buf: Buffer) {
  const sig = 0x06054b50;
  const minEOCD = 22;                     
  const maxComment = 0xffff;              
  const start = Math.max(0, buf.length - (minEOCD + maxComment));

  for (let i = buf.length - minEOCD; i >= start; i--) {
    if (readU32(buf, i) === sig) {
      const disk = readU16(buf, i + 4);
      const cdDisk = readU16(buf, i + 6);
      const entriesOnDisk = readU16(buf, i + 8);
      const entriesTotal = readU16(buf, i + 10);
      const cdSize = readU32(buf, i + 12);
      const cdOffset = readU32(buf, i + 14);
      const commentLen = readU16(buf, i + 20);
      return { disk, cdDisk, entriesOnDisk, entriesTotal, cdSize, cdOffset, commentLen, eocdOffset: i };
    }
  }
  return null;
}


export function previewZipCentralDirectory(buf: Buffer, opts?: { maxEntries?: number }): Preview | null {
  const eocd = findEOCD(buf);
  if (!eocd) return null;

  const sigCD = 0x02014b50;
  const entries: Entry[] = [];
  let off = eocd.cdOffset;
  const limit = opts?.maxEntries ?? eocd.entriesTotal;

  for (let n = 0; n < eocd.entriesTotal && n < limit; n++) {
    if (off + 46 > buf.length) break;
    if (readU32(buf, off) !== sigCD) break;

    const _versionMadeBy = readU16(buf, off + 4);
    const _versionNeeded = readU16(buf, off + 6);
    const gpFlag = readU16(buf, off + 8);
    const method = readU16(buf, off + 10);
    const _time = readU16(buf, off + 12);
    const _date = readU16(buf, off + 14);
    const _crc = readU32(buf, off + 16);
    const compSize = readU32(buf, off + 20);
    const uncompSize = readU32(buf, off + 24);
    const nameLen = readU16(buf, off + 28);
    const extraLen = readU16(buf, off + 30);
    const commentLen = readU16(buf, off + 32);


    const nameStart = off + 46;
    const nameEnd = nameStart + nameLen;
    const name = buf.subarray(nameStart, nameEnd).toString('utf8');

    const isDir = name.endsWith('/');
    const encrypted = (gpFlag & 0x0001) === 0x0001;

    let ratio: number | null = null;
    if (uncompSize > 0) {
      ratio = 1 - compSize / uncompSize; 
    }

    entries.push({
      name,
      compressedSize: compSize,
      uncompressedSize: uncompSize,
      method,
      encrypted,
      isDirectory: isDir,
      compressionRatio: ratio,
    });

    off = nameEnd + extraLen + commentLen;
  }

  const files = entries.filter(e => !e.isDirectory);
  const dirs = entries.length - files.length;

  const compressed = files.reduce((a, e) => a + e.compressedSize, 0);
  const uncompressed = files.reduce((a, e) => a + e.uncompressedSize, 0);
  const overallRatio = uncompressed > 0 ? 1 - compressed / uncompressed : null;

  const highExpansionEntries = files
    .filter(e => e.uncompressedSize > 0 && (e.uncompressedSize / Math.max(1, e.compressedSize)) >= 50) 
    .map(e => ({
      name: e.name,
      ratio: e.uncompressedSize / Math.max(1, e.compressedSize),
      uncompressedSize: e.uncompressedSize,
      compressedSize: e.compressedSize
    }));

  const highOverallExpansion = uncompressed > 0 && (uncompressed / Math.max(1, compressed)) >= 100; 

  return {
    entries,
    totals: { files: files.length, dirs, compressed, uncompressed, overallRatio },
    suspicious: { highExpansionEntries, highOverallExpansion }
  };
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\next.config.ts
================================================================================

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\next-env.d.ts
================================================================================

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\types\proofread.ts
================================================================================

export type ProofreadEdit = {
  start: number;
  end: number;
  original: string;
  suggestion: string;
  reason: string;
  severity: "minor" | "major";
};

export type ProofreadResult = {
  corrected: string;
  edits: ProofreadEdit[];
};



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\types\upload.ts
================================================================================

export type AnalyzedItem = {
  id: string;           
  name: string;         
  type: "image" | "html" | "other";
  size: number;
  url: string;
  previewUrl?: string;
  html?: boolean;
};

export type UploadAnalysis = {
  uploadId: string;
  isSingleCreative: boolean;
  items: AnalyzedItem[];
  counts: { images: number; htmls: number; others: number; total: number };
};



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\utils\errorHandling.ts
================================================================================

// Error types
export enum ErrorType {
  VALIDATION = 'VALIDATION',
  NETWORK = 'NETWORK',
  UPLOAD = 'UPLOAD',
  AUTHENTICATION = 'AUTHENTICATION',
  UNKNOWN = 'UNKNOWN'
}

export interface AppError {
  type: ErrorType
  message: string
  code?: string
  details?: unknown
  timestamp: Date
}

// Error messages
export const ERROR_MESSAGES = {
  VALIDATION: {
    REQUIRED_FIELD: 'This field is required',
    INVALID_EMAIL: 'Please enter a valid email address',
    INVALID_TELEGRAM_ID: 'Please enter a valid Telegram ID',
    FILE_TOO_LARGE: 'File size exceeds the maximum limit',
    INVALID_FILE_TYPE: 'File type not supported',
    INVALID_OFFER: 'Please select a valid offer'
  },
  NETWORK: {
    CONNECTION_FAILED: 'Connection failed. Please check your internet connection.',
    TIMEOUT: 'Request timed out. Please try again.',
    SERVER_ERROR: 'Server error. Please try again later.',
    API_UNAVAILABLE: 'Service temporarily unavailable.'
  },
  UPLOAD: {
    FAILED: 'File upload failed. Please try again.',
    INCOMPLETE: 'Upload incomplete. Please try again.',
    STORAGE_FULL: 'Storage limit reached. Please contact support.',
    VIRUS_DETECTED: 'File rejected due to security concerns.'
  },
  AUTHENTICATION: {
    INVALID_CREDENTIALS: 'Invalid credentials. Please try again.',
    SESSION_EXPIRED: 'Session expired. Please log in again.',
    INSUFFICIENT_PERMISSIONS: 'You do not have permission to perform this action.',
    ACCOUNT_LOCKED: 'Account temporarily locked. Please contact support.'
  }
}

// Error creation
export const createError = (
  type: ErrorType,
  message: string,
  code?: string,
  details?: unknown
): AppError => {
  return {
    type,
    message,
    code,
    details,
    timestamp: new Date()
  }
}

// Error handling functions
export const handleValidationError = (fieldName: string, value: string): AppError => {
  if (!value.trim()) {
    return createError(
      ErrorType.VALIDATION,
      ERROR_MESSAGES.VALIDATION.REQUIRED_FIELD,
      'REQUIRED_FIELD'
    )
  }
  
  if (fieldName === 'email' && !isValidEmail(value)) {
    return createError(
      ErrorType.VALIDATION,
      ERROR_MESSAGES.VALIDATION.INVALID_EMAIL,
      'INVALID_EMAIL'
    )
  }
  
  if (fieldName === 'telegramId' && !isValidTelegramId(value)) {
    return createError(
      ErrorType.VALIDATION,
      ERROR_MESSAGES.VALIDATION.INVALID_TELEGRAM_ID,
      'INVALID_TELEGRAM_ID'
    )
  }
  
  return createError(
    ErrorType.VALIDATION,
    `Invalid ${fieldName}`,
    'INVALID_FIELD'
  )
}

export const handleUploadError = (error: { code?: string }): AppError => {
  if (error.code === 'FILE_TOO_LARGE') {
    return createError(
      ErrorType.UPLOAD,
      ERROR_MESSAGES.UPLOAD.FAILED,
      'FILE_TOO_LARGE'
    )
  }
  
  if (error.code === 'INVALID_FILE_TYPE') {
    return createError(
      ErrorType.UPLOAD,
      ERROR_MESSAGES.UPLOAD.FAILED,
      'INVALID_FILE_TYPE'
    )
  }
  
  return createError(
    ErrorType.UPLOAD,
    ERROR_MESSAGES.UPLOAD.FAILED,
    'UPLOAD_FAILED'
  )
}

export const handleNetworkError = (error: { code?: string }): AppError => {
  if (error.code === 'NETWORK_ERROR') {
    return createError(
      ErrorType.NETWORK,
      ERROR_MESSAGES.NETWORK.CONNECTION_FAILED,
      'NETWORK_ERROR'
    )
  }
  
  if (error.code === 'TIMEOUT') {
    return createError(
      ErrorType.NETWORK,
      ERROR_MESSAGES.NETWORK.TIMEOUT,
      'TIMEOUT'
    )
  }
  
  return createError(
    ErrorType.NETWORK,
    ERROR_MESSAGES.NETWORK.SERVER_ERROR,
    'SERVER_ERROR'
  )
}

// Helper functions
const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}

const isValidTelegramId = (telegramId: string): boolean => {
  if (!telegramId || telegramId === '@') return false
  const telegramRegex = /^@[a-zA-Z0-9_]{5,32}$/
  return telegramRegex.test(telegramId)
}

// Error logging
export const logError = (error: AppError): void => {
  console.error('Application Error:', {
    type: error.type,
    message: error.message,
    code: error.code,
    timestamp: error.timestamp,
    details: error.details
  })
}

// User-friendly error messages
export const getUserFriendlyMessage = (error: AppError): string => {
  switch (error.type) {
    case ErrorType.VALIDATION:
      return error.message
    case ErrorType.NETWORK:
      return ERROR_MESSAGES.NETWORK.CONNECTION_FAILED
    case ErrorType.UPLOAD:
      return ERROR_MESSAGES.UPLOAD.FAILED
    case ErrorType.AUTHENTICATION:
      return ERROR_MESSAGES.AUTHENTICATION.INVALID_CREDENTIALS
    default:
      return 'Something went wrong. Please try again.'
  }
}



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\utils\index.ts
================================================================================

// Export all utility functions
export * from './validations'
export * from './errorHandling'



================================================================================
FILE: C:\Users\yashp\OneDrive\Desktop\job\projects\Creative_System2\Creative-Management-System\utils\validations.ts
================================================================================

// File validation constants
export const FILE_VALIDATION = {
  SINGLE_CREATIVE: {
    ALLOWED_TYPES: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'text/html', 'application/zip'],
    MAX_SIZE_MB: Infinity,
    ACCEPT_EXTENSIONS: '.jpg,.jpeg,.png,.gif,.webp,.html,.zip'
  },
  MULTIPLE_CREATIVES: {
    ALLOWED_TYPES: ['application/zip'],
    MAX_SIZE_MB: Infinity,
    ACCEPT_EXTENSIONS: '.zip'
  }
}

// Form field validation
export const validateRequired = (value: string): boolean => {
  return value.trim().length > 0
}

export const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return emailRegex.test(email)
}

export const validateTelegramId = (telegramId: string): boolean => {
  if (!telegramId || telegramId === '@') return false
  const telegramRegex = /^@[a-zA-Z0-9_]{5,32}$/
  return telegramRegex.test(telegramId)
}

export const validateFileType = (file: File, allowedTypes: string[]): boolean => {
  return allowedTypes.includes(file.type) || 
         allowedTypes.some(type => file.name.toLowerCase().endsWith(type.toLowerCase()))
}

export const validateFileSize = (file: File, maxSizeMB: number): boolean => {
  return file.size <= maxSizeMB * 1024 * 1024
}

// Form validation helpers
export const getFieldError = (fieldName: string, value: string, isRequired: boolean = true): string => {
  if (isRequired && !validateRequired(value)) {
    return `${fieldName} is required`
  }
  
  if (fieldName === 'email' && value && !validateEmail(value)) {
    return 'Please enter a valid email address'
  }
  
  if (fieldName === 'telegramId' && value && !validateTelegramId(value)) {
    return 'Please enter a valid Telegram ID (e.g., @username)'
  }
  
  return ''
}

// File upload validation
export const validateFileUpload = (
  file: File, 
  allowedTypes: string[], 
  maxSizeMB: number
): { isValid: boolean; errorMessage: string } => {
  if (!validateFileType(file, allowedTypes)) {
    return {
      isValid: false,
      errorMessage: `Please select a valid file type: ${allowedTypes.join(', ')}`
    }
  }
  
  if (!validateFileSize(file, maxSizeMB)) {
    return {
      isValid: false,
      errorMessage: `File size must be less than ${maxSizeMB}MB`
    }
  }
  
  return { isValid: true, errorMessage: '' }
}


